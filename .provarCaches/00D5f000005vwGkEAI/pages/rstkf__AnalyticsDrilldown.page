<apex:page controller="rstkf.AnalyticsDrilldownCon" sidebar="false" showHeader="false" title="Interactive Financial Reports: Drilldown" standardStylesheets="false" docType="html-5.0">
    <apex:includeLightning />
    
    <script src="../../soap/ajax/38.0/connection.js" type="text/javascript" />    

    <apex:stylesheet value="{!URLFOR($Resource.rstkf__slds100, '/assets/styles/salesforce-lightning-design-system.css')}"/>
    <apex:stylesheet value="{!URLFOR($Resource.rstkf__FontAwesome, '/css/font-awesome.min.css')}"/>
    <apex:stylesheet value="{!URLFOR($Resource.rstkf__KendoUIStyles20153930, '/styles/kendo.common.min.css')}"/>    
    <apex:stylesheet value="{!URLFOR($Resource.rstkf__KendoUIStyles20153930, '/styles/kendo.bootstrap.min.css')}"/>  
    <apex:stylesheet value="{!$Resource.rstkf__KenandyCommonStyles}" />    
    <apex:stylesheet value="{!$Resource.rstkf__drilldown}" />    
        
    <apex:includeScript value="{!URLFOR($Resource.rstkf__KendoUI, '/js/jquery.min.js')}"/>    
    <apex:includeScript value="{!URLFOR($Resource.rstkf__KendoUIScripts20153930, '/scripts/js/kendo.all.min.js')}"/>
    <apex:includeScript value="{!$Resource.rstkf__filesaver_js}" />
    <apex:includeScript value="{!$Resource.rstkf__Analytics}" />
    <apex:includeScript value="{!$Resource.rstkf__RootstockCommon}" /> 
    
        <script type="text/javascript">
            var namespace = '{!namespace}';

            //=====================================
            // patching one function in the connection.js resource, so we don't get 
            // Refused to set unsafe header "User-Agent" errror
            
           console.log('trying to load lightening component');
           var stencilcomponent; 
           var objinstance;
           $Lightning.use("{!compNS}:stencilcontainerapp", function() {
                $Lightning.createComponent("{!compNS}:stencil",
                                           { },
                                           "lightningcontainer",
                                           function(cmp) {
                                               stencilcomponent = cmp;
                                               console.log('component was created and rendered successfully');
                                               //objinstance = stencilcomponent.find("lastcontainer");
                                               //$(objinstance).css('border','1px solid black');
                                               
                                           });
            });
            
            
            sforce.Transport = function(url) {
            this.url = url;
            this.connection = null;
            
            this.newConnection = function() {
                try {
                    this.connection = new ActiveXObject('Msxml2.XMLHTTP');
                } catch(e) {
                    try {
                        this.connection = new ActiveXObject('Microsoft.XMLHTTP');
                    } catch(e) {
                        this.connection = new XMLHttpRequest();
                    }
                }
                
                return this.connection;
            };
            
            this.send = function (envelope, callback, async, timeout) {
                this.newConnection();
                if (async) {
                    this.connection.onreadystatechange = this.httpConnectionCallback;
                }
                var holder = new sforce.internal.ConnectionHolder(this.connection, callback);
                sforce.internal._connections.push(holder);
                this.connection.open("POST", this.url, async);
                this.connection.setRequestHeader("Content-Type", "text/xml; charset=UTF-8");
                this.connection.setRequestHeader("SOAPAction", "\"\"");
                this.connection.setRequestHeader("Accept", "text/xml");
                //this.connection.setRequestHeader("User-Agent", "SFAJAX 1.0"); //here is the one line we are patching
                this.connection.send(envelope);
                if (async && typeof(timeout) !== "undefined") {
                    this.setTimeoutOn(holder, timeout);
                }
                if (!async) {
                    this.httpConnectionCallback();
                }
            };
            
            this.setTimeoutOn = function (holder, timeout) {
                function abortConnection() {
                    if (holder.connection.readyState !== 4) {
                        holder.timedout = true;
                        holder.connection.abort();
                    }
                }
                setTimeout(abortConnection, timeout);
            };
            
            this.httpConnectionCallback = function () {
                
                for (var i = 0; i < sforce.internal._connections.length; i++) {
                    var holder = sforce.internal._connections[i];
                    if (holder !== null) {
                        if (holder.timedout) {
                            sforce.internal._connections[i] = null;
                            sforce.internal._connections.slice(i,1);
                            holder.callback.httpCallback("Remote invocation timed out", false);
                        } else  if (holder.connection.readyState == 4) {
                            sforce.internal._connections[i] = null;
                            sforce.internal._connections.slice(i,1);
                            var success = holder.connection.status == 200;
                            if (sforce.debug.trace) {
                                sforce.debug.log("Response : status - " + holder.connection.status);
                                sforce.debug.logXml(holder.connection.responseText);
                            }
                            if (sforce.debug.apexTrace) {
                                sforce.debug.logApex(holder.connection.responseText);
                            }
                            if (holder.connection.responseXML && holder.connection.responseXML.documentElement) {
                                holder.callback.httpCallback(holder.connection.responseXML.documentElement, success);
                            } else {
                                holder.callback.httpCallback("Remote invocation failed, due to: " + holder.connection.responseText +
                                                             " status code: ", holder.connection.status);
                            }
                        }
                    }
                }
            };
        };
    //END PATCH =======================================    
    </script>


    
    <script type="text/javascript">
    
    //Set AJAX timeout to 15 mins (conversion to MS)
    var AJAXtimeout = 15 * (60 * 1000);     
    var chunkSize = 50000;  //default
    sforce.connection.sessionId = "{!$Api.Session_ID}"; 
    
    var chunkList = {};
    
    var offsetIdMap = {};
    var totalQueryMoreSize = {};
    var totalQueriesCompleted = {};    
    var objectQueriesCompleted = {};
    var objectAllQueriesCompleted = {};     
    var errors = [];

    var chunkListGlobal;    
    var drilldownFields = [];
    var gridData = [];
    var currencyISO = '';    
   
    var totalFacts = 0;
    
    var drilldowndata = JSON.parse('{!JSENCODE(JSONdrilldowndata)}');
    var model = drilldowndata.model;
    var reportMetadata = drilldowndata.reportMetadata;
    var filtersApplied = drilldowndata.filtersApplied;
    var drilldownfilter = drilldowndata.filter;
    var segmentNodes = drilldowndata.segmentNodes;
    var prefixes = JSON.parse('{!JSENCODE(JSONobjPrefixes)}');
    var arrFilterObj = [];
    var filters = [];
    var showDetails = false;
    var aeLookupFields = JSON.parse('{!JSENCODE(JSONaeLookupFields)}');
    console.log('aeLookupFields');
    console.log(aeLookupFields);
    var entityFields = JSON.parse('{!JSENCODE(JSONentityFields)}');
    console.log('entityFields');
    console.log(entityFields);
    var descFields = JSON.parse('{!JSENCODE(JSONdescFields)}');
    console.log('descFields');
    console.log(descFields);    
    
    var useGLcontra = {!useGLcontra};
    var contraFieldName = 'gltxn_glacct__r.glacct_cfr_contra_account__c';//KNDY4__GL_Account__r.KNDY4__GL_Type__r.KNDY4__Contra__c';
    if (useGLcontra) {
        contraFieldName = 'gltxn_glacct__r.glacct_cfr_contra_account__c';
    }         
    
    $(document).ready(function() {
        $('#grid').hide();
        console.log('drilldowndata');
        console.log(drilldowndata);
        console.log('prefixes');
        console.log(prefixes);
        

        for(key in drilldownfilter){
            debugger;
            filtersApplied[key] = [drilldownfilter[key]];
        }
        console.log('drilldown override filtersapplied');
        console.log(filtersApplied);

        buildFilters();
    });
    
    function buildFilters() {
        arrFilterObj = [];

        //pushing report source infomation for report header
        arrFilterObj.push({
            'includeChildren'   : false,
            'addToQuery'        : false, //already in our fact, don't need to add it again
            'label'             : 'Source Report',
            'field'             : 'rifr_rpt_type__c',
            'objName'           : 'rifr_rpt_type__c',
            'vals'              : [{
                                        'id'    :   resolveValue(reportMetadata.frList[0], 'Id'),
                                        'name'  :   resolveValue(reportMetadata.frList[0], 'rifr_rpt_type__c')
                                  }]
        });
        
        arrFilterObj.push({
            'includeChildren'   : false,
            'addToQuery'        : false, //already in our fact, don't need to add it again
            'label'             : 'Company',
            'field'             : 'rifr_cmpno__c',
            'objName'           : 'rifr_cmpno__c',
            'vals'              : [{
                                        'id'    :   resolveValue(reportMetadata.frList[0], 'rifr_cmpno__c'),
                                        'name'  :   resolveValue(reportMetadata.frList[0], 'rifr_cmpno__r.Name')
                                  }]
        });
        
        for (var i=0; i<model.dimensions.length; i++) {
            var dim = model.dimensions[i];
            var isnodeExpanded = drilldowndata.isExpandednode;
            var includenodeChild = true;
            if(dim.objName == 'KNDY4__GL_Account__c' && isnodeExpanded == "true"){
                includenodeChild = false;
            }
            arrFilterObj.push({
                'includeChildren'   : includenodeChild,
                'addToQuery'        : true,
                'label'             : dim.title,
                'field'             : getDimFieldFromObj(dim.objName),
                'objName'           : dim.objName,
                'vals'              : getDimFilterTitles(dim.objName)
            });            
        }        
        
        
        if (drilldowndata.reportMetadata.frList[0].KNDY4__Report_Type__c == StatementType.MCTB) {        
            
            var arrYid = drilldowndata.yId.split('_');
            if (arrYid.length > 1) {
                arrYid = arrYid[1].split('/');
                if (arrYid.length == 2) {
                    if (drilldowndata.xId == 'Transactional_Currency') {
                        currencyISO = arrYid[0];
                    } else if (drilldowndata.xId == 'Functional_Currency') {
                        currencyISO = arrYid[1];
                    }                    
                }
            }
            
            arrFilterObj.push({
                'includeChildren'   : false,
                'addToQuery'        : false,
                'label'             : 'Currency Code',
                'field'             : 'currency',
                'objName'           : 'currency',
                'vals'              : [{
                                        'id'    :   currencyISO,
                                        'name'  :   currencyISO
                                      }]
            });                   
        }        
            
        console.log('arrFilterObj');
        console.log(arrFilterObj);
        
        renderHeader();
        buildQueryFilters();        
    }
    
    
    function renderHeader() {
        var headerHtml = '';
        for (var i=0; i<arrFilterObj.length; i++) {
            var headerDim = arrFilterObj[i];
            if (headerDim.vals.length > 0) {
                headerHtml += '<p>';
                var s = (headerDim.vals.length > 1 ? 's' : '');
                headerHtml += '<span class="slds-text-heading--label">' + headerDim.label + s + ': </span>';
                for (j=0; j<headerDim.vals.length; j++) {
                    var val = headerDim.vals[j];
                    var delim = (j<(headerDim.vals.length-1) ? ', ' :  '');
                    if (val.id != null && val.id.length == 18) {
                        headerHtml += '<a href="/' + val.id + '" target="_blank" class="slds-text-heading">' + val.name + '</a>' + delim;
                    } else {
                        headerHtml += '<span class="slds-text-heading">' + val.name + '</span>' + delim;
                    }    
                }
                headerHtml += '</p>';            
            }
        }
        $("#headerFilters").html(headerHtml);
    }

    
    

    function getDimFieldFromObj(objName) {
        //this function takes in the name of the object, and gets the actual field on the object which points to it.
        //hard coding to 'a' alias for now.  only supports first object.
        var dimField;
        for (var i=0; i<model.dimensions.length; i++) {
            var dim = model.dimensions[i];
            if (dim.objName == objName) {
                dimField = dim.fields.a;
                break;
            }
        }
        return dimField;
    }
    
    function getDimFilterTitles(dimField) {
        var arrVals = [];
        
        //there are 2 ways you could be filtered on a dim.  the dim filters at the top of the report,
        //or by clicking on the row column intersection.  If this dim is one of the rows or columns we are going to
        //use that instead, since that is the most specific.
        
        if (model.xAxis == dimField) {
            arrVals.push({
                'id'    :   drilldowndata.xId,
                'name'  :   getDimValName(dimField, drilldowndata.xId)
            });
        }  else if (dimField in filtersApplied) {
            var filters = filtersApplied[dimField];
            if (filters != null) {
                filterTitles = '';
                var arrFilterRange = [];
                if ($.isArray(filters)) {
                    arrFilterRange = filters;
                } else {
                    arrFilterRange.push(filters);   
                }
                
                for (var i=0; i<arrFilterRange.length; i++) {
                    var filter = arrFilterRange[i];
                    arrVals.push({
                        'id'    :   filter,
                        'name'  :   getDimValName(dimField, filter)
                    });                    
                }            
            }
        }
        return arrVals;
    }
    
    function getDimValName(dimField, dimVal) { 
        var dimValName;
        if (dimField in segmentNodes) {
            var nodes = segmentNodes[dimField];
            if (dimVal in nodes) {
                var node = nodes[dimVal];
                dimValName = node.name;
            }
        }
        return dimValName;
    }
    
    function getFirstDim(yId) {
        //multi currency has a composite y axis with 3 dims like this: a1L4100000061LHEAY_EUR/USD
        //split off the first
        if (drilldowndata.reportMetadata.frList[0].KNDY4__Report_Type__c == StatementType.MCTB) {        
            var arrYid = drilldowndata.yId.split('_');
            if (arrYid.length > 1) {
                yId = arrYid[0];
            }
        }
        return yId;        
    }
    
    function buildFields() {
        //all the fields we want to display in the drill down grid
        drilldownFields = [];
        
        drilldownFields.push({  
            'alias' : 'a',
            'field' : 'gltxn_trandate__c', //KNDY4__Source_Name__c
            'title' : 'Transaction Date',
            'type'  : 'date',
            'hidden': false
        });   
        
        drilldownFields.push({  
            'alias' : 'a',
            'field' : 'gltxn_dimval1__c',
            'title' : 'Dimension 1',
            'type'  : 'text',
            'hidden': false
        });            
        
        drilldownFields.push({  
            'alias' : 'a',
            'field' : 'gltxn_dimval2__c',
            'title' : 'Dimension 2',
            'type'  : 'text',
            'hidden': false
        });               
        
        drilldownFields.push({  
            'alias' : 'a',
            'field' : 'gltxn_dimval3__c',
            'title' : 'Dimension 3',
            'type'  : 'text',
            'hidden': false
        }); 
        
        drilldownFields.push({  
            'alias' : 'a',
            'field' : 'gltxn_dimval4__c',
            'title' : 'Dimension 4',
            'type'  : 'text',
            'hidden': false
        }); 
        
        drilldownFields.push({
            'alias' : 'a',
            'field' : 'gltxn_dramt__c',
            'title' : 'Dr Amount',
            'type'  : 'currency',
            'hidden': false
        });
        
        drilldownFields.push({  
            'alias' : 'a',
            'field' : 'gltxn_cramt__c',
            'title' : 'Cr Amount',
            'type'  : 'currency',
            'hidden': false
        });
        drilldownFields.push({
            'alias' : 'a',
            'field' : 'gltxn_gltxnsum__r.Balance_f__c',
            'title' : 'Balance',
            'type'  : 'currency',
            'hidden': false//(drilldowndata.met == 'a_KNDY4__Balance_f__c' ? false : true),
        });
        
        //loop through the dimensions in the model and add those as well
        for (var i=0; i<model.dimensions.length; i++) {
            var dim = model.dimensions[i];

            addDim = true;
            if (drilldowndata.reportMetadata.frList[0].KNDY4__Report_Type__c == StatementType.MCTB) {       
                if (dim.objName == 'AEL_currencyType' || dim.objName == 'AEL_transFunctCurr') {
                    addDim = false;
                }
            }    

            if (addDim) {
                drilldownFields.push({  
                    'alias' : 'a',
                    'field' : dim.fields.a, //only supports alias 'a', first object
                    'title' : dim.title,
                    'type'  : 'relationship',
                    'hidden': false
                });                   
            }
   
        }
        
        
        var DRhidden = (drilldowndata.met == 'a_KNDY4__COMP_Functional_Currency_Amount_DR__c' || drilldowndata.met == 'a_DR' ? false : true);
        if (drilldowndata.reportMetadata.frList[0].KNDY4__Report_Type__c == StatementType.BS) {
            DRhidden = false;
        }
        var reportType = drilldowndata.reportMetadata.frList[0].KNDY4__Report_Type__c;
        if (reportType == StatementType.TB || reportType == StatementType.MCTB) {
            if (drilldowndata.met == 'Balance_f__c') {
                DRhidden = false;
            }    
        }        
        drilldownFields.push({
            'alias'  : 'a',
            'field'  : 'KNDY4__COMP_Functional_Currency_Amount_DR__c',
            'title'  : 'Amount DR',
            'type'   : 'currency',
            'hidden' : DRhidden,
            'ohidden': DRhidden,
            'toggle' : true
        });

        
        var CRhidden = (drilldowndata.met == 'a_KNDY4__COMP_Functional_Currency_Amount_CR__c' || drilldowndata.met == 'a_CR' ? false : true);
        if (drilldowndata.reportMetadata.frList[0].KNDY4__Report_Type__c == StatementType.BS) {
            CRhidden = false;
        }        
        if (reportType == StatementType.TB || reportType == StatementType.MCTB) {  
            if (drilldowndata.met == 'Balance_f__c') {
                CRhidden = false;
            }    
        }            
        /*drilldownFields.push({
            'alias'  : 'a',
            'field'  : 'KNDY4__COMP_Functional_Currency_Amount_CR__c',
            'title'  : 'Amount CR',
            'type'   : 'currency',
            'hidden' : CRhidden,
            'ohidden': CRhidden,
            'toggle' : true
        });   
        
        drilldownFields.push({
            'alias' : 'a',
            'field' : 'KNDY4__Balance_f__c',
            'title' : 'Balance',
            'type'  : 'currency',
            'hidden': true,//(drilldowndata.met == 'a_KNDY4__Balance_f__c' ? false : true),
            'ohidden':true,// (drilldowndata.met == 'a_KNDY4__Balance_f__c' ? false : true),
            'toggle': true
        });


        drilldownFields.push({
            'alias' : 'a',
            'field' : contraFieldName,
            'title' : 'Contra',
            'type'  : 'Boolean',
            'hidden':  (drilldowndata.met == ('a_'+contraFieldName) ? false : true),
            'ohidden': (drilldowndata.met == ('a_'+contraFieldName) ? false : true),
            'toggle': true
        });*/
        
        drilldownFields.push({
            'alias' : 'a',
            'field' : 'gltxn_glacct__r.glacct_cfr_gl_type__r.gltype_normalbal__c',
            'title' : 'Normal Balance',
            'type'  : 'currency',
            'hidden': true,
            'ohidden': true,
            'toggle': false
        });
        
        /*drilldownFields.push({
            'alias' : 'a',
            'field' : 'KNDY4__GL_Account__r.KNDY4__GL_Type__r.KNDY4__Statement_Type__c',
            'title' : 'Statement Type',
            'type'  : 'text',
            'hidden': true,
            'ohidden': true,
            'toggle': false
        });
        
        drilldownFields.push({
            'alias' : 'a',
            'field' : 'KNDY4__GL_Account__r.KNDY4__Cash_Flow_Report_Section_Grouping__c',
            'title' : 'Report Section Group',
            'type'  : 'text',
            'hidden': true,
            'ohidden': true,
            'toggle': false
        }); */         

        model.drilldownFields = drilldownFields;
        
        console.log('model.drilldownFields');
        console.log(model);        
        
    }
    
    
    function buildQueryFilters() {
        
        for (var i=0; i<arrFilterObj.length; i++) {
            var f = arrFilterObj[i];
            if (f.addToQuery && (f.vals.length > 0)) {
                
                var Ids = [];
                //If logic to remove _total from f.vals
                //e.g in f.vals value is id:"a1E50000000bap8EAA_total" so removing it to consider to show the AEL's
                if(f.vals[0].id.indexOf('_total') != -1){
                    var localvarid = f.vals[0].id;
                    f.vals[0].id = localvarid.substring(0, localvarid.indexOf('_total'));
                }
                if(f.includeChildren) {
                    Ids = getChildIds(f.objName, f.vals);
                } else {
                    Ids = getIds(f.vals);
                }
                // Handling empty segment placeholder
                if(f.vals.length > 0){
                    if(f.vals[0].id.endsWith('_empty')){
                        Ids[0] = '';
                    }
                }
                filters.push({
                    'field' :   f.field,
                    'in'    :   Ids
                });                 
            }
        }
        var mode = drilldowndata.mode;
        console.log('mode: ' + mode);
        
        //now filter out any filter values which aren't proper for that object.
        //for example on GL's filter out the grouping section Ids since they don't resolve directly to GL Account Ids.  we instead 
        //query for all the child GLs under them.
        //for periods we don't query for fiscial years or quarters, we filter those out.  just filter by periods.
        
        //console.log('filters filters filters');
        //console.log(JSON.parse(JSON.stringify(filters)));

        var currencyISO;
        
        for (var i=0; i<filters.length; i++) {
            var filter = filters[i].in;
            var filterValid = [];
            for (var j=0; j<filter.length; j++) {
                var id = filter[j];
                
                if (drilldowndata.reportMetadata.frList[0].KNDY4__Report_Type__c == StatementType.MCTB) {        
                    var arrYid = id.split('_');
                    if (arrYid.length > 1) {
                        id = arrYid[0];
                        arrYid = arrYid[1].split('/');
                        if (arrYid.length == 2) {
                            if (drilldowndata.xId == 'Transactional_Currency') {
                                currencyISO = arrYid[0];
                            } else if (drilldowndata.xId == 'Functional_Currency') {
                                currencyISO = arrYid[1];
                            }                    
                        }
                    }                    
                }    
                
                //the id is invalid if not 18 digits, or doesn't start with a proper object prefix for our dimensions.
                //could be enhanced to make sure it is the exact right object as well, but don't see the need for now.
                var validId = true;
                if (id.length == 18) {
                    if (prefixes.indexOf(id.substring(0,3)) == -1) {
                        validId = false;
                    }
                } else {
                    validId = false;
                }
                // Handling empty segment
                if(id == ''){
                    validId = true;
                }
                //if id is invalid, remove it from the filters to avoid SOQL query errors
                if (validId) {
                     filterValid.push(id);
                }
            }
            filters[i].in = filterValid;
        }
        
        console.log('filters');
        console.log(filters);     
        
        //see if we need to get a cumulative date filter or not
        var cumPeriodIds;
        for (var i=0; i<filters.length; i++) {
            var filter = filters[i];
            if ( (filter.field == 'KNDY4__Period__c') && (mode == 'cum') ) {
                cumPeriodIds = filter.in;
            }
        }
        if (cumPeriodIds == null) {
            buildFiltersFinish(null);
        } else {
            getCumulativeDateFilter(cumPeriodIds);
        }
        
    }
    
    
    function getCumulativeDateFilter(periodIds) {
        var query =
        'SELECT Id, KNDY4__Period_End__c ' +
        'FROM KNDY4__Period__c ' +
        'WHERE Id IN(\'' + periodIds.join("','") + '\') ' +
        'AND KNDY4__Period_End__c != NULL ' +
        'ORDER BY KNDY4__Period_End__c DESC ' +
        'LIMIT 1';
        
        console.log('getCumulativeDateFilter query');
        console.log(query);        

        var sfresult = sforce.connection.query(query, {
            onSuccess: function(result) {
                console.log('result');
                console.log(result);
                
                var records = result.getArray("records");
                console.log('getCumulativeDateFilter records');
                console.log(records);        

                var maxPeriodEnd;
                for (var i=0; i< records.length; i++) {
                    var record = records[i];
                    maxPeriodEnd = record.KNDY4__Period_End__c;
                }        
                console.log('maxPeriodEnd: ' + maxPeriodEnd);
                
                if (maxPeriodEnd == null) {
                    var qErr = {};
                    qErr.status = false;
                    qErr.type = 'exception';
                    qErr.message = 'Can\'t locate period end for cumulative balances.';
                    checkErrors (qErr);     
                } else {
                    var cumulativeDateFilter = 'KNDY4__Accounting_Entry__r.KNDY4__Posting_Date__c < ' + maxPeriodEnd;
                    buildFiltersFinish(cumulativeDateFilter);
                }
            },
            onFailure: function(error) {
                console.log('error');
                console.log(error);                
                
                var qErr = {};
                qErr.status = false;
                qErr.type = 'exception';
                qErr.message = 'Problem getting query locator: ' + error;
                checkErrors (qErr);                 
            }, 
            timeout: AJAXtimeout
        });         

        console.log('sforce.connection.query sfresult');
        console.log(sfresult);    

    }    
    
    
    
    function buildFiltersFinish(cumulativeDateFilter) {
        //build an array of all the filter strings
        var arrQueryFilters = [];
        for (var i=0; i<filters.length; i++) {
            var filter = filters[i];
            if ( (filter.field == 'KNDY4__Period__c') && (cumulativeDateFilter != null) ) {
                arrQueryFilters.push(cumulativeDateFilter);
            } else if (filter.in.length == 0 && filter.field == 'KNDY4__GL_Account__c'){
                arrQueryFilters.push( filter.field  + '= null' );
            } else {
                if (filter.in.length > 0) {
                    arrQueryFilters.push( filter.field + ' IN(\'' + filter.in.join("','") + '\')');
                }
            }
        }
        
        //for multi currency trial balance we want to add in a filter for the trans or funct currency as well
        if (drilldowndata.reportMetadata.frList[0].KNDY4__Report_Type__c == StatementType.MCTB) {     
            if (drilldowndata.xId == 'Transactional_Currency') {
                arrQueryFilters.push('KNDY4__COMP_Transaction_Currency__c = \'' + currencyISO + '\'');
            } else if (drilldowndata.xId == 'Functional_Currency') {
                arrQueryFilters.push('KNDY4__COMP_Functional_Currency__c = \'' + currencyISO + '\'');
            }
        }
        
        
        console.log('arrQueryFilters');
        console.log(arrQueryFilters);
        
        //"AND" the array of strings together into one string
        var sFilter = arrQueryFilters.join(' AND ');
        
        console.log('sFilter');
        console.log(sFilter);
          

        //and tack it onto the model's filter
        var hasFilter = false;
        if ('filter' in model.facts[0]) { //ONLY SUPPORTS DRILLDOWN ON FIRST FACT!
            if ((model.facts[0].filter != null) && (model.facts[0].filter != '')) {
                hasFilter = true;
            }
        }
        
        if (sFilter != '') {
            if (hasFilter) {
                model.facts[0].filter += ' AND ' + sFilter;
            } else {
                model.facts[0].filter = sFilter;
            }
        }

        console.log('model.facts[0].filter');
        console.log(model.facts[0].filter);

        buildFields();
        chunkEntireDB(model.facts[0].obj);
    }
    
    function getIds(nodes){
        var myids = nodes.map(x => x.id);
        return myids;
    }

    function getChildIds(dim, nodes) {
        //console.log('getChildIds dim nodes');
        //console.log(dim);
        //console.log(nodes);
        var nodeAndChildren = []; 

        for (var i=0; i<nodes.length; i++) {
            var node = nodes[i];
            
            if (drilldowndata.reportMetadata.frList[0].KNDY4__Report_Type__c == StatementType.MCTB) {  
                 if (dim == 'KNDY4__GL_Account__c') {    
                     node.id = drilldowndata.yId; //need the full nodeid will all the dims on the yaxis, not just the one dim
                 }
            }
            
            node = drilldowndata.segmentNodes[dim][node.id]; //get the node from the collection of nodes and the Id            
            //push in the top parent node we are drilling into        
            nodeAndChildren.push(node.id);
            
            //get all the descendants down the line from this node.
            recurseFlatNodesFindChildren(nodeAndChildren, node, drilldowndata.segmentNodes[dim]);            
            
        }

        return nodeAndChildren;
    }
    
    

    function recurseFlatNodesFindChildren(nodeAndChildren, node, nodes) {

        for (var id in nodes) {
            if (nodes.hasOwnProperty(id)) {
                var n = nodes[id];
                
                //if we already added this node to the array, skip it
                if (nodeAndChildren.indexOf(n.id) != -1) {
                    continue;
                }
                
                if (n.parentId == node.id) {
                    nodeAndChildren.push(n.id);
                    recurseFlatNodesFindChildren(nodeAndChildren, n, nodes);
                }                
            }
        }
    }        
    

    
    
    
    
    
    
    
    
    //=========================================================
    // START QLPK Chunks
    //=========================================================        
    
    
    var objectNameGlobal;
    function chunkEntireDB(objectName) {

        objectNameGlobal = objectName; //WARNING, this won't support multiple object queries
        
        chunkList[objectName] = [];
        objectQueriesCompleted[objectName] = 0;
        objectAllQueriesCompleted[objectName] = false;
        
        totalQueriesCompleted[objectName] = 0;
        
        var SOQL = ("SELECT Id FROM " + objectName + " ORDER BY Id");
        console.log('SOQL: '+ SOQL);
        
        var result = sforce.connection.query(SOQL, {
            onSuccess: function(result) {
                
                console.log('success');
    
                var resultValues = getResultValues(result);

                console.log('result');
                console.log(result);
                  
                console.log('resultValues');
                console.log(resultValues);
                
                var objectName = resultValues.type;     

                //add the first result to our object before we fire off all the subsequent ones in parallel
                if(resultValues.type in offsetIdMap) {
                    offsetIdMap[objectName][resultValues.offset] = resultValues; 
                } else {    
                    offsetIdMap[objectName] = {};
                    offsetIdMap[objectName][resultValues.offset] = resultValues; 
                }
        
            
                if (resultValues.totalSize <= 2000) {
                    //this means there is no cursor Id, we got all the records returned to us
                    //chunk is just the first and last Id in the locator, jump right to success
                    totalQueryMoreSize[objectName] = 1;
                    qmSuccess(result);                  
                } else {
                    //> 2000 records means that we need to chunk
                    
                    //get the loop size
                    var loopSize = Math.floor(resultValues.totalSize / chunkSize);
                    
                    //we need to know ahead of time how many times we are going to call doQueryMore, so when the 
                    //results come back async, we know if we are done or not
                    totalQueryMoreSize[objectName] = loopSize;
            
                    //in case it didn't divide evenly, will have to fire off one more query of a custom size
                    //the offset will be the total number of records in the querylocator minus the leftover
                    //EX: 100,002, R=2, offset = 100,002 - 2 = 100,000
                    var remainder = resultValues.totalSize % chunkSize;     
                    
                    //in some cases we don't need another queryMore for the remainder.
                    //if total records - running total is less than chunk size, the last id query will get us everything
                    var runningTotal = (chunkSize * loopSize);
                    if ((resultValues.totalSize - runningTotal) < chunkSize) {
                        remainder = 0;
                    }
                    
                    //if the chunks divide perfectly into the totalSize, subtract one from the loopsize
                    //otherwise we will be requesting an offset that doesn't exist at the end.
                    if ((resultValues.totalSize - runningTotal) == 0) {
                        loopSize--;
                        totalQueryMoreSize[objectName]--;
                    }
                    
                    if (remainder > 0) {
                        totalQueryMoreSize[objectName] ++;
                    }   
                
                    //add in one more for the query of the last Id
                    totalQueryMoreSize[objectName] ++;
            
                    //fire off all the queryMore's for loopSize
                    for (var i=1; i<=loopSize; i++) {
                        var offset = chunkSize * i;
                        doQueryMore(resultValues.cursorId, offset); 
                    } 
                    
                    //fire off one more if there was a remainder
                    if (remainder > 0) {
                        var offset = (resultValues.totalSize - remainder);
                        doQueryMore(resultValues.cursorId, offset);     
                    }               
            
                    //now fire off one more to get the last Id in the cursor
                    var offset = (resultValues.totalSize - 1);
                    doQueryMore(resultValues.cursorId, offset);                     
                }

            
            },
            onFailure: function(error) {
                var qErr = {};
                qErr.status = false;
                qErr.type = 'exception';
                qErr.message = 'Problem getting query locator: ' + error;

                checkErrors (qErr);                 
            }, 
            timeout: AJAXtimeout
        });     
        


    }

    function doQueryMore(cursorId, offset) {
        var ql = cursorId + '-' + offset;
        console.log('queryMore ql');
        console.log(ql);
        sforce.connection.queryMore(ql, {
            onSuccess: qmSuccess,
            onFailure: queryError,
            timeout: AJAXtimeout
        });
    }
    
    function qmSuccess(result) {
    
        //console.log('result');
        //console.log(result);      
        
        var resultValues = getResultValues(result);


        console.log('resultValues');
        console.log(resultValues);  
        
        if (resultValues.type in offsetIdMap) {
            offsetIdMap[resultValues.type][resultValues.offset] = resultValues; 
        } else {    
            offsetIdMap[resultValues.type] = {};
            offsetIdMap[resultValues.type][resultValues.offset] = resultValues; 
        }
        totalQueriesCompleted[resultValues.type] ++;

        console.log(totalQueryMoreSize[resultValues.type] + ', ' + totalQueriesCompleted[resultValues.type]);
        if (totalQueryMoreSize[resultValues.type] == totalQueriesCompleted[resultValues.type]) {
            allQueriesComplete(resultValues.type);
        }
    }

    function queryError(error) {
        var qErr = {};
        qErr.status = false;
        qErr.type = 'exception';
        qErr.message = 'error';
        
        checkErrors (qErr);
    }

    function getResultValues(result) {
        var retObj = {};
        retObj.totalSize = -1;
        retObj.cursorId = '';
        retObj.offset = 999999999999; //~1T records.  using this to put last result at the end of the sort, its QL will be null
        retObj.firstRecordId = '';
        retObj.lastRecordId = '';
        retObj.type = '';
        
        //get the querylocator from the result
        var ql = result.queryLocator;
        
        //ql will look like this:
        //01gJ000000IYnYLIA1-2000
        
        //split the ql into cursorId and offset
        if (ql != null) { //if there are no more records to get, ql will be null
            var arrQL = ql.split('-');
            if (arrQL.length == 2) {
                retObj.cursorId = arrQL[0];
                retObj.offset   = arrQL[1];
            }   
        }

        
        //get the total size, convert to int
        retObj.totalSize = parseInt(result['size']);        
        
        //get the first record Id
        var firstRecordFound = false;
        if ('records' in result) {
            //see if it is in an array
            if (Object.prototype.toString.call(result.records) === '[object Array]') {
                if (result.records.length > 0) {
                    retObj.firstRecordId = result.records[0].Id;
                    retObj.type = result.records[0].type;
                    firstRecordFound = true;
                }           
            } else {
                //or else just a single object
                if ('Id' in result.records) {
                    retObj.firstRecordId = result.records.Id;
                    retObj.type = result.records.type;
                    firstRecordFound = true;                
                }
            }
        }
        
        //get the last record Id
        var lastRecordFound = false;
        if ('records' in result) {
            //see if it is in an array
            if (Object.prototype.toString.call(result.records) === '[object Array]') {
                if (result.records.length > 0) {
                    retObj.lastRecordId = result.records[result.records.length-1].Id;
                    lastRecordFound = true;
                }           
            } else {
                //or else just a single object
                if ('Id' in result.records) {
                    retObj.lastRecordId = result.records.Id;
                    lastRecordFound = true;             
                }
            }
        }

        //WARNING: this won't support multiple objects
        if (retObj.type == '') {
            retObj.type = objectNameGlobal;
        }
        
        return retObj;
    }




    function allQueriesComplete(type) {
        
        //build an array of all the keys so we can sort them
        var offsetArray = [];
        for (var offset in offsetIdMap[type]) {
            offsetArray.push(parseInt(offset));
        }
                                            
        offsetArray.sort(function(a,b) { return a - b; });
        
        //loop from the beginning to the next to last one
        //don't need the last since it just contains the very last Id - special case
        
        if(offsetArray.length==1) {
            var range = {};
            
            range.first = offsetIdMap[type][offsetArray[0]].firstRecordId;
            range.last = offsetIdMap[type][offsetArray[0]].lastRecordId;
            range.isLast = true;
            chunkList[type].push(range);
            
        } else {
            
            for (var i=0; i<(offsetArray.length-1); i++) {
                var range = {};
                range.first = '';
                range.last = '';
                range.isLast = false;
                
                var currOffset = offsetArray[i];
                var nextOffset = offsetArray[i+1];
                range.first = offsetIdMap[type][currOffset].firstRecordId;
            
                var lastLoop = false;
                if (i == (offsetArray.length-2)) {
                    lastLoop = true;
                }
    
                if (lastLoop) {
                    range.isLast = true;
                    
                    //the last Id will be the actual last Id from the very last chunk
                    range.last  = offsetIdMap[type][nextOffset].lastRecordId;
                } else {
                    //the last Id will be the first from the next chunk (have to use < logic)
                    range.last  = offsetIdMap[type][nextOffset].firstRecordId;          
                }
                chunkList[type].push(range);
                
            }
        }
        
        
        
        console.log('chunkList');
        console.log(chunkList);

        console.log('*** QLPK done***');    
        
        //now kick off the chunk queries
        chunkListGlobal = chunkList[type];
        
        parallelStart();

    }       

    //=========================================================
    // END QLPK Chunks
    //=========================================================    
    
    
    
    
    
    
    
    //=========================================================
    // BEGIN Query Chunks
    //=========================================================

            
    
    //TODO: make these variables we can pass in
    var numSimultaneous = 1000;
    var numberOfRetries = 15;
    
    var chunkRetries = {};
    var startTimestamp = {};        
    
    var numTotal = 0;
    var numRemainingTotal = 0;
    var numRemainingBatch = 0;
    
    
    function parallelStart() {
        console.log('parallelStart');
        
        console.log('chunkListGlobal');
        console.log(chunkListGlobal);
        
        numTotal = chunkListGlobal.length;
        numRemainingTotal = numTotal;
        getNextBatch();
    }       
    
    function getNextBatch() {
        console.log('getNextBatch ' + numRemainingTotal);
        if (numRemainingTotal == 0) {
            parallelEnd();
            console.log('parallel end');
            $('#lightningcontainer').hide();
            $('#grid').show();
            $('#grid').css('overflow','auto');
            
        } else {
            var nextBatchStartIndex = numTotal - numRemainingTotal;
            
            //get the number of simultaneous chunks, or whatever is left if it's less
            numRemainingBatch = numSimultaneous;
            if (numRemainingTotal < numRemainingBatch) {
                numRemainingBatch = numRemainingTotal;
            }                       
            chunkWorker(nextBatchStartIndex, numRemainingBatch);
        }
    }       
    
    function chunkWorker(nextBatchStartIndex, numRemainingBatch) {
        console.log('chunkWorker ' + nextBatchStartIndex);
        for (var i=0; i<numRemainingBatch; i++) {
            updateStatus(1, 'Data Requested: ' + (nextBatchStartIndex+i+1) + '/' + numTotal +  '. ');               
            getChunk(nextBatchStartIndex+i);
        }       
    }    
    
    function chunkComplete(result, event) {
        numRemainingBatch--;
        numRemainingTotal--;
        updateStatus(2, 'Received: ' + (numTotal-numRemainingTotal) + '/' + numTotal + '.');
    
        //process the fact
        processResult(result);          
            
        if (numRemainingBatch == 0) {
            getNextBatch();
        }
    }       
    
    
    function parallelEnd() {
    }                 
    
    var facts = [];
    function processResult(result) {
        console.log('processResult result');
        console.log(result);

        RootstockErp.CleanObject(result, namespace);
        console.log(result);

        var counter = 0;
        var batchCounter = 1;
        
        for (var i=0; i<result.length; i++) {
            totalFacts++;
            counter++;
            var record = result[i];
            // getting more info of the record and overriding to match the drilldown total
            var contra = resolveValue(record, contraFieldName);
            var normalBal = resolveValue(record, 'KNDY4__GL_Account__r.KNDY4__GL_Type__r.KNDY4__Normal_Balance__c');
            var stmtType = resolveValue(record, 'KNDY4__GL_Account__r.KNDY4__GL_Type__r.KNDY4__Statement_Type__c');
            var cashFlowSection = resolveValue(record, 'KNDY4__GL_Account__r.KNDY4__Cash_Flow_Report_Section_Grouping__c');
            var DR = resolveValue(record, 'gltxn_cramt__c');
            var CR = resolveValue(record, 'gltxn_dramt__c');  
            var reportType = reportMetadata.frList[0]['rifr_rpt_type__c'];
            
            
            //for multi currency TB, if we are drilling into transactional, override the default functional field to be transactional
            if (drilldowndata.reportMetadata.frList[0].KNDY4__Report_Type__c == StatementType.MCTB) {     
                if (drilldowndata.xId == 'Transactional_Currency') {
                    DR = resolveValue(record, 'KNDY4__COMP_Transaction_Currency_Amount_DR__c');
                    CR = resolveValue(record, 'KNDY4__COMP_Transaction_Currency_Amount_CR__c');
                }
            }               
            

            DR = (DR == null ? 0 : DR);
            CR = (CR == null ? 0 : CR);
            
            var DRbalance = (normalBal == 'Debit');
            
            //post fall 2016 - normalBal is derived on contras as the opposite of the GL Type's normal bal
            if (useGLcontra && contra) {
                if (normalBal == 'Debit') {
                    normalBal = 'Credit';
                } else {
                    normalBal = 'Debit';
                }
            }
            
            //pre fall 2016 - normalBal comes from the GL type field.  account and contra account have different normal balances
            if ((!useGLcontra) && contra) {
                DRbalance = !DRbalance;
            }   
            
            //for trial balance we are always going to do DRbalance (DR - CR)
            if (reportType == StatementType.TB || reportType == StatementType.MCTB) {
                DRbalance = true;
            }
            
            var balance = 0;
            if (DRbalance) {
                balance = DR - CR;
            } else {
                balance = CR - DR;    
            }
            
            if (reportType == StatementType.CF && (stmtType == StatementType.BS && DRbalance) && cashFlowSection != 'Cash') {
                balance *= -1;
            }
            record['Balance_f__c'] = balance;
            
            //override the KNDY4__Source_Reference__c and KNDY4__Source_Document_Object_Name__c fields with better values
            var sourceDocLookup = getLookupInfo(record, aeLookupFields);
            //record.KNDY4__Accounting_Entry__r.KNDY4__Source_Reference__c = sourceDocLookup.id;
            //record.KNDY4__Accounting_Entry__r.KNDY4__Source_Document_Object_Name__c = sourceDocLookup.name;
            
            //populate the EntityId / Names
            var entityLookup = getLookupInfo(record, entityFields);
            //record.EntityId = entityLookup.id;
            //record.EntityName = entityLookup.name;  
            
            //populate the Desc
            record.Description = getPopulatedValue(record, descFields);
            
            //In some cases, KNDY4__Source_ID__c may look like this: a0z41000001QDSwAAO|RFX
            //so we need to split on pipe and get the first element
            if ('KNDY4__Source_ID__c' in record) {
                if (record.KNDY4__Source_ID__c != null) {
                    record.KNDY4__Source_ID__c = record.KNDY4__Source_ID__c.split('|')[0];
                }
            }
            
            processResultWorker(record);
        }
        
        if (numRemainingTotal == 0) {
            processResultComplete();
        }            
         
    }
    
    
    //this function loops through all the lookup fields 
    //and finds the first one that is populated
    function getLookupInfo(record, fieldIdsNames) {
        var lookup = {'id': '', 'name': ''};
        
        for (var i=0; i<fieldIdsNames.length; i++) {
            var l = fieldIdsNames[i];
            var idVal = resolveValue(record, l.id);
            
            if (idVal != null) {
                var nameVal = resolveValue(record, l.name, 'name not found');
                lookup.id = idVal;
                lookup.name = nameVal;
                return lookup;
            }    
        }    
        return lookup;
    }
    
    //this field loops through a bunch of text fields and returns the first one that is populated
    function getPopulatedValue(record, fieldsToCheck) {
        for (var i=0; i<fieldsToCheck.length; i++) {
            var f = fieldsToCheck[i];
            var v = resolveValue(record, f);
            
            if ( (v != null) && (v != '') ) {
                return v;
            }
        }    
        return '';
    }    
    
    
    function processResultWorker(record) {
        //console.log('processResultWorker record');        
        //console.log(record);    
        
        //transform the data a bit. We need to flatten the relationships out.
        var newRecord = {};
        
        for (var i=0; i<model.drilldownFields.length; i++) {
            var dd = model.drilldownFields[i];
            
            var ddVal = resolveValue(record, dd.field);
            
            if ( (dd.type == 'date') && (ddVal != null) ) {
                var datetime = new Date(ddVal);
                ddVal = datetime;
            }
            
            newRecord[kendoNameSafe(dd.field)] = ddVal;
            
            if (dd.type == 'relationship') {
                //add the name field too
                var nameFieldName = getNameFieldName(dd.field);
                newRecord[kendoNameSafe(nameFieldName)] = resolveValue(record, nameFieldName);
            }
      
        }
        
        
        //for multi currency TB, if we are drilling into transactional add that field as well
        if (drilldowndata.reportMetadata.frList[0].KNDY4__Report_Type__c == StatementType.MCTB) {     
            if (drilldowndata.xId == 'Transactional_Currency') {
                newRecord['KNDY4__COMP_Transaction_Currency_Amount_DR__c'] = resolveValue(record, 'KNDY4__COMP_Transaction_Currency_Amount_DR__c');
                newRecord['KNDY4__COMP_Transaction_Currency_Amount_CR__c'] = resolveValue(record, 'KNDY4__COMP_Transaction_Currency_Amount_CR__c');
            }
        }                
        
        gridData.push(newRecord);
    }
    
    function kendoNameSafe(nameIn) {
        //replace periods with underscores
        var nameOut = nameIn.replace(/\./g,'_');
        return nameOut;
    }
    
    //given some Id or lookup __c it returns the name of the corresponding name field for that object
    function getNameFieldName(field) {
        var nameField = field;
        var fieldLcase = field.toLowerCase();
        
        var endsWithC = false;
        if (fieldLcase.length > 2) {
            if (fieldLcase.slice(-3) == '__c') {
                endsWithC = true;
            }
        }
        
        if (fieldLcase == 'entityid') {
             nameField = 'EntityName'; 
        } else if (fieldLcase == 'kndy4__source_id__c') {     
            //special case for source doc
            nameField = 'KNDY4__Source_Name__c';      
        } else if (fieldLcase == 'kndy4__accounting_entry__r.kndy4__source_reference__c') {
            nameField = 'KNDY4__Accounting_Entry__r.KNDY4__Source_Document_Object_Name__c';   
        } else if (endsWithC) {
            nameField = nameField.substring(0, nameField.length-3);
            nameField += '__r.Name';
        } else if (fieldLcase == 'id') {
            nameField = 'Name';
        } else {
            //standard fields
            if (fieldLcase.slice(-2) == 'id') {
                nameField = nameField.substring(0, -2);
            }
            if (nameField.slice(-1) == '.') {
                nameField = nameField.substring(0, -1);
            }
            nameField += '.Name';
        }
        
        return nameField;
    }
    
    function processResultComplete() {
        var drilldownreportType = drilldowndata.reportMetadata.frList[0].rifr_rpt_type__c;   
        var localstoragekey = 'kendo-grid-options-'+drilldownreportType;
        var showhidecolumnsarray = [];
        var parsedata;

        console.log('processResultComplete gridData');        
        console.log(gridData);

        var columns = [];
        var baseTemplate,blankTemplate = '';
        if(localStorage[localstoragekey] != '' && localStorage[localstoragekey] != undefined){
            parsedata = JSON.parse(localStorage[localstoragekey]);
        }        
        
        for (var i=0; i<model.drilldownFields.length; i++) {
            var dd = model.drilldownFields[i];
            
            var field = dd.field;
            
            //for multi currency TB, if we are drilling into transactional, override the default functional field to be transactional
            if (drilldowndata.reportMetadata.frList[0].rifr_rpt_type__c  == StatementType.MCTB) {     
                if (drilldowndata.xId == 'Transactional_Currency') {
                    if (field == 'KNDY4__COMP_Functional_Currency_Amount_DR__c') {
                        field = 'KNDY4__COMP_Transaction_Currency_Amount_DR__c';
                    } else if (field == 'KNDY4__COMP_Functional_Currency_Amount_CR__c') {
                        field = 'KNDY4__COMP_Transaction_Currency_Amount_CR__c';
                    }
                }
            }                    

            var col = {
                'field' : kendoNameSafe(field), 
                'title' : dd.title,
                'type'  : dd.type,
                'toggle': ('toggle' in dd ? dd.toggle : false),
                'hidden': dd.hidden,
                'ohidden': ('ohidden' in dd ? dd.ohidden : false)
            }
            //adding templates
            baseTemplate = '<div style="text-align:right;">#= kendo.toString('+col.field+', "n2" ) #</div>';
            blankTemplate = '<span></span>'; 
            //hide the Id column, we don't want to see that, but need it for the hyperlink
            if (dd.type == 'relationship') {
                col.hidden = true;
                col.menu = false;
            }
            
            if (dd.type == 'date') {            
                col.template = '#= kendo.toString('+col.field+', "MM/dd/yyyy hh:mm tt" ) #';
            }            

            if (dd.type == 'currency') {            
                col.template = 
                "#if("+col.field+" != null) " +
                    "{ #" + baseTemplate + "#} " +
                "else " +
                    "{ #" + blankTemplate + "#}#"; 
            }                 
            
            columns.push(col);
            
            if (dd.type == 'relationship') {
                //add the name field, not hidden
                var nameFieldName = getNameFieldName(dd.field);

                var nameCol = {
                    'field' : kendoNameSafe(nameFieldName), 
                    'title' : dd.title,
                    'type'  : dd.type,
                    'idField' : col.field
                }
                    
                columns.push(nameCol);
            }
        }        
        
        
        var schema = {};
        schema.model = {};
        schema.model.fields = {};
        
        var aggregate = [];
        
        var dataSource = {};
        dataSource.data = gridData;
        dataSource.schema = schema;
        dataSource.pageSize = 20;        
        
        for (var i=0; i<columns.length; i++) {
            var col = columns[i];
            var field = {};
            if (col.type == 'currency') {
                field.type = 'number';
            } else if (col.type == 'date') {
                field.type = 'date';
            } else {
                field.type = 'string';
            }

            // following logic to set the columns hidden based on grid older state
            if(parsedata != undefined){
                parsedata.map(function(x){
                    if(col.field == x.field){
                        return col.hidden = x.hidden;
                    }
                });
            }
            
            dataSource.schema.model.fields[col.field] = field;
            
            if (col.type == 'currency') {
                aggregate.push({'field': col.field, 'aggregate': 'sum'});
                col.aggregates = ['sum'];
                baseTemplate = '<div style="text-align:right;">Total: #=kendo.toString(sum, \'n2\')#</div>'
                col.footerTemplate = 
                    "# if(sum == null){ #" +
                        "" +
                    "#} else {#" +
                        baseTemplate +
                    "# } #";
            }
            
            if ((col.type == 'relationship') && (!col.hidden)) {
                col.template = '#if('+col.idField+' != null) {#<a href="/#='+col.idField+'#" target="_blank">#='+col.field+'#</a>#} else{""}#';
            }
            
        }
        
        
        dataSource.aggregate = aggregate;        

        
        console.log('columns');
        console.log(columns);        
        
        console.log('dataSource');
        console.log(dataSource);
        var localstoragekey = 'kendo-grid-options-'+drilldownreportType;
        //render the grid
        $("#grid").kendoGrid({
            dataSource: dataSource,
            reorderable: true,
            scrollable: false,
            sortable: true,
            filterable: true,
            columnMenu: true,
            pageable: {
                input: true,
                numeric: false
            },              
            columns: columns,
            columnReorder: function(e){
                persistkendocolumnState(localstoragekey);
            },
            columnHide: function(e) {
                persistkendocolumnState(localstoragekey);
            },
            columnShow: function(e) {
                persistkendocolumnState(localstoragekey);
            }
        });

        // Grid loading persisted columns state if any
        if(localStorage[localstoragekey] !== undefined){
            try{
                var localgridinstance = $("#grid").data("kendoGrid");
                var jsoncolumns = JSON.parse(localStorage[localstoragekey]); 
                localgridinstance.setOptions({ columns: jsoncolumns });
            }
            catch (err){
                $('#dverror').show();
            }
        }
    }
    // persist kendocolumns state to localstorage
    function persistkendocolumnState(storagekey){
        var localgrid = $("#grid").data("kendoGrid");
        if(localStorage[storagekey] == undefined){
            localStorage[storagekey] = '';
        }
        setTimeout(function(){
            localStorage[storagekey] = '';
            localStorage[storagekey] = kendo.stringify(localgrid.columns);
        },500);
    }

    function getURL(field) {
    
    }
    
    
    function getChunk(startAt) {
        var firstId = chunkListGlobal[startAt]["first"];
        var lastId = chunkListGlobal[startAt]["last"];
        var isLast = chunkListGlobal[startAt]["isLast"];
        
        startTimestamp[startAt] = new Date().getTime();
        
        //pass in the fields for Entity and Description as additional fields to add to the query
        var additionalFields = [];
        for (var i=0; i<entityFields.length; i++) {
            var e = entityFields[i];
            additionalFields.push(e.id);
            additionalFields.push(e.name);
        }
        for (var i=0; i<descFields.length; i++) {
            additionalFields.push(descFields[i]);
        }        
        
        
        Visualforce.remoting.Manager.invokeAction(
            '{!$RemoteAction.AnalyticsDrilldownCon.queryChunk}',
            JSON.stringify(drilldowndata), JSON.stringify(model), additionalFields, 'a', firstId, lastId, isLast,
            function (result, event) {
                
                //trap any timeouts
                var isTimeout = false;
                if (event.type === 'exception') {
                    if (event.message.indexOf("timeout") > -1) {
                        isTimeout = true;   
                    }   
                }       
                    
                if (isTimeout == false) {
                    checkErrors(event);
                }
                
                if (event.status) {
                    chunkComplete(result, event);
                }
    
                if (isTimeout) {
                    if (startAt in chunkRetries) {
                        chunkRetries[startAt]++;
                    } else {
                        chunkRetries[startAt] = 1;
                    }
                    
                    if (chunkRetries[startAt] <= numberOfRetries) {
                        var msExec = (new Date().getTime()) - startTimestamp[startAt];
                    
                        console.log('retry: ' + chunkRetries[startAt] + ', ' + firstId + ' - ' + lastId + ', ms: ' + msExec + ', curr time: ' + new Date());
                        getChunk(startAt);
                    } else {
                        //we hit our number of retries, time to fail
                        checkErrors(event);
                        chunkComplete();                        
                    }
                    
                }
                
            },
            {escape: false, buffer: false}
        );          
    }        


    
    //=========================================================
    // END Query Chunks
    //=========================================================    
    
    
    



    var checkErrors = function (event) { 
        var errorMsg;
        if (event.status) {            
            //do nothing, no error
        } else if (event.type === 'exception') {
            errorMsg = event.message + ' : ' + event.type;
        } else {
            errorMsg = event.message;
        }
        
        if (errorMsg != null) {
            window.parent.postMessage({"type": "error", "error": errorMsg}, "*");       
        }
        
    };      
    
    
    var updateStatus = function (msgLocation, statusMsg) { 
        console.log('status: (' + msgLocation + ') ' + statusMsg);
    }; 
    
    
    
    //this function takes a salesforce object in JSON
    //and a relationship query style field reference like this: KNDY4__GL_Account__r.Name
    //and pulls the value we want out of the nested object(s)
    function resolveValue(obj, path, nullReplace) {
        
        var retVal = null;
        if (path.indexOf('.') == -1) {
            if (path in obj) {
                retVal = obj[path];
            }
        } else {
            //loop through all the keys to fully resolve the final, nested value in the object tree
            var arrPath = path.split('.');
            var val = obj;
            for (var i=0; i<arrPath.length; i++) {
                key = arrPath[i];
                if (key in val) {
                    val = val[key];
                    retVal = val;
                } else {
                    retVal = null;
                    break;
                }
            }
        } 
        
        if ((nullReplace != null) && (retVal == null)) {
            retVal = nullReplace;
        }
        return retVal;
    }    
    
    // buidling csv data
    function buildCSV(gridId){
        var fileName = 'drilldowndata_'+Date.now()+'.csv';
        var grid = $("#" + gridId).data("kendoGrid");
        var originalPageSize = grid.dataSource.total(); //grid.dataSource.pageSize();
        var csv = '';
        fileName = fileName || 'download.csv';
        
        // Get total records size from the datasource
        grid.dataSource.pageSize(originalPageSize);
        var data = grid.dataSource.view();
        
        //add the header row
        for (var i = 0; i < grid.columns.length; i++) {
            var field = grid.columns[i].field;
            var title = grid.columns[i].title || field;
            var type = grid.columns[i].type;
            
            //NO DATA
            if (!field) continue;
            
            title = title.replace(/"/g, '""');
            if('idField' in grid.columns[i] || type != 'relationship'){
                csv += '"' + title + '"';
                if (i < grid.columns.length - 1) {
                    csv += ',';
                }
            }
        }
        csv += '\n';
        
        //add each row of data
        for (var row in data) {
            for (var i = 0; i < grid.columns.length; i++) {
                var fieldName = grid.columns[i].field;
                var template = grid.columns[i].template;
                var exportFormat = grid.columns[i].exportFormat;
                var type = grid.columns[i].type;
                //VALIDATE COLUMN
                if (!fieldName) continue;
                var value = '';
                
                if('idField' in grid.columns[i] || type != 'relationship'){
                    value = data[row][fieldName] || '';
                    value = value.toString().replace(/"/g, '""');
                    csv += '"' + value + '"';
                    if (i < grid.columns.length - 1) {
                        csv += ',';
                    }
                }
            }
            csv += '\n';
        }
        
        // Reset datasource
        grid.dataSource.pageSize(originalPageSize);
        
        // Export to browser
        var blob = new Blob([csv], { type: 'text/csv;charset=utf-8' }); //Blob.js
        saveAs(blob, fileName); //FileSaver.js
    }
    //csv export function 
    function csvExport(){
        buildCSV('grid');

        //hiding csv button
        $('#downarrow').removeClass('slds-is-open');
        $('#downarrow').add('slds-is-false');
    }
    //clicking on arrow opens and close csv option by toggling class
    function toggleExport(){
        $('#downarrow').removeClass('slds-is-false');
        $('#downarrow').addClass('slds-is-open');
    }
    
    
    
    </script>
    
    <div class="slds">  
        
        <div class="slds-page-header" role="banner">
            <div class="slds-grid">
                <div class="slds-col slds-has-flexi-truncate">
                    <div class="slds-media">
                        <div class="slds-media__figure">
                            <img src="{!$Resource.rslandinglogo}"/>            
                        </div>
                        <div class="slds-media__body">
                            <p class="slds-text-heading--label">Drilldown Report</p>
                            <div class="slds-grid">
                                <h1 class="slds-page-header__title slds-m-right--small slds-truncate slds-align-middle" title="Interactive Financial Reports">Interactive Financial Reports</h1>
                            </div>
                            <span id="headerFilters"/>
                        </div>
                    </div>
                </div>
                
                <div class="slds-col slds-no-flex slds-align-bottom">
                    <div class="slds-button-group" role="group">
                        <div id="downarrow" class="slds-dropdown-trigger slds-dropdown-trigger--click slds-button--last slds-is-false">
                            <button class="slds-button slds-button--neutral" aria-haspopup="true" onclick="toggleExport()">Export 
                                &nbsp;
                                <svg aria-hidden="true" class="slds-button__icon">
                                    <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="{!URLFOR($Resource.slds100, 'assets/icons/utility-sprite/svg/symbols.svg#down')}" />
                                </svg>
                            </button>
                            <div class="slds-dropdown slds-dropdown--right">
                                <ul class="dropdown__list" role="menu">
                                    <li class="slds-dropdown__item" role="presentation">
                                        <a href="javascript:void(0);" onclick="csvExport()" role="menuitem" tabindex="1">
                                            <span class="slds-truncate">CSV</span>
                                        </a>
                                    </li>
                                </ul>
                            </div>  
                        </div>
                    </div>
                   
                         
                    
                </div>
            </div>
        </div>
        <div class="slds-notify_container">
            <div id="dverror" class="slds-notify slds-notify--alert slds-theme--error slds-theme--alert-texture" style="display:none;" role="alert">
                <button class="slds-button slds-notify__close slds-button--icon-inverse" title="Close" onclick="$(this).parent().hide();">
                    <svg aria-hidden="true" class="slds-button__icon expand">
                        <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="{!$Resource.slds100 + '/assets/icons/utility-sprite/svg/symbols.svg#close'}" />
                    </svg>
                    <span class="slds-assistive-text">Close</span>
                </button>
                <span class="slds-assistive-text">Error</span>
                Please try to clear the cache and try again.
            </div>
        </div>
        <div id="lightningcontainer" style="display:block" />
        <div id="grid" class="grid" style="display:none;"/>
    </div>        
    
    
    
    
</apex:page>