<apex:page standardStylesheets="false" showHeader="false" sidebar="false" controller="rstkf.AnalyticsServiceCon" docType="html-5.0">

<apex:includeScript value="{!$Resource.rstkf__jison}"/>     
<apex:includeScript value="{!URLFOR($Resource.rstkf__KendoUIScripts20153930, '/scripts/js/jquery.min.js')}"/>
<apex:includeScript value="{!URLFOR($Resource.rstkf__KendoUIScripts20153930, '/scripts/js/kendo.all.min.js')}"/>
<apex:includeScript value="{!$Resource.rstkf__filesaver_js}" />  
<apex:includeScript value="{!$Resource.rstkf__Analytics}" />      

    
<script src="../../soap/ajax/38.0/connection.js" type="text/javascript" />
<apex:includeScript value="{!$Resource.rstkf__lumenize}" />



<script type="text/javascript">
    
Visualforce.remoting.timeout = 120000; // Set timeout at page level
    
var totalFacts = 0;    
var pdfNumFormat = 'n2'; //TODO: make this a setting somewhere

//================================================================
// BEGIN lumenize OLAP functions
//================================================================   

// DOCS: 
// http://commondatastorage.googleapis.com/versions.lumenize.com/docs/lumenize-docs/index.html#!/api/Lumenize.OLAPCube

var lumenize = require('/lumenize');


//Utility function
function buildConfigFromModel(model) {
    var dimensions = [];
    var metrics = [];
    
    for (i=0; i<model.dimensions.length; i++) {
        if (model.dimensions[i].hierarchy) {
            dimensions.push({field: model.dimensions[i].objName, type: 'hierarchy'});
        } else {
            dimensions.push({field: model.dimensions[i].objName});
        }
    }
    
    for (i=0; i<model.metrics.length; i++) {
        if (model.metrics[i].metType == 'Data') { //don't put the calculated metrics in the cube
            var metric = {};
            metric.field = model.metrics[i].alias + '_' + model.metrics[i].field;
            metric.f = 'sum';
            metric.as = metric.field;
            metrics.push(metric);               
        }
    }   
    
    return {dimensions: dimensions, metrics: metrics};
}

//================================================================
// END lumenize OLAP functions
//================================================================   



    //Set AJAX timeout to 15 mins (conversion to MS)
    var AJAXtimeout = 15 * (60 * 1000);     
    var chunkSize = 30000;  //default

    sforce.connection.sessionId = "{!$Api.Session_ID}"; 
    var chunkList = {};
    var offsetIdMap = {};
    var totalQueryMoreSize = {};
    var totalQueriesCompleted = {};    
    var objectQueriesCompleted = {};
    var objectAllQueriesCompleted = {};     
    var objToDimensionsMap = {};
    //var objToAliasedDimMetMap = {};    
    var aliasToMetricMap = {};       
    
    var keyDataMap = {};    
    
    var errors = [];
    
    var OLAPconfig;
    var config;
    var dimToIsHierMap;
    //var chunkListGlobal;

    var OLAPCube;
    var cube;
    var model;
    var report;
    var reportMetadata;
    var asmRep;
    var presentationData = [];
    var xAxisObj;
    var hide0Bal;    
    var hideTotal;
    var dispXaxisObj;
    var dispXaxisObjDimToMetMap;
    var timeDisplaySettings;
    var filtersApplied;
    var begBalFilter;    
    var filtersAppliedPathMap;    
    var segmentNodePathMap;
    var segmentNodes;
    var segmentHierarchy;
    var segmentFlat;
    var hierarchy;
    var revenueGLs;
    var expenseGLs;
    var mixedContraGLtypes;
    var format;
    var serverTimeFormattedFile;
    var dimQueryResults;
    var hierachyQueryResults;    
    var expandedNodesForPDF;
    var period13mapData;
    var useGLcontra = {!useGLcontra};
    var contraFieldName = 'gltxnsum_glacct__r.glacct_cfr_contra_account__c';
    if (useGLcontra) {
        contraFieldName = 'gltxnsum_glacct__r.glacct_cfr_contra_account__c';
    }        
    var repForPresentation;    

    var isIndentedTree;
    var isFlatRollup;
    
    //BEGIN Code Adopted from Raja Rao =====================================
    //mirrored here: https://github.com/kenandy/misc/tree/master/SFRestApp
    
    window.addEventListener("message", messageHandler, false);
    window.parent.postMessage({"type": "ready"}, "*");
    
    // END Code Adopted from Raja Rao ===================================== 
    
    function messageHandler(event) {
        console.log('messageHandler event: ');
        console.log(event);
            
        var data = event.data;
        var type = data.type;

        if (type === "queryHierarchy") {
            OLAPconfig = data;
            reportMetadata = data.reportMetadata;
            queryHierarchy();
        }
        
        if (type === "build") {
            //set the global var with this data so all the methods can access it
            OLAPconfig = data;
            //console.log('OLAPconfig');
            //console.log(OLAPconfig);
            model = OLAPconfig.model;
            
            report = OLAPconfig.report;
            segmentNodePathMap = OLAPconfig.segmentNodePathMap;
            mixedContraGLtypes = OLAPconfig.mixedContraGLtypes;      
            console.log('mixedContraGLtypes', mixedContraGLtypes);
            
            //initialize the OLAP cube
            initOLAP();
            
            startChunking(data);
        }
        
        if (type === "reconstitute") {
            //set the global var with this data so all the methods can access it
            OLAPconfig = data;
            console.log('reconstitute OLAPconfig');
            console.log(OLAPconfig);
            
            report = OLAPconfig.report;
            segmentNodePathMap = OLAPconfig.segmentNodePathMap;
     
            //reconstitute the OLAP cube
            reconstituteOLAP();
        }        
        
        
        if (type === "query") {
            //To do a query we need: 
            //xAxis and yAxis hierarchy 
            //xAxis hierarchy gets passed in as its own object
            //yAxis hierarchy is part of the report structure
            //we already have the OLAP cube built in memory
            
            report = data.report;
            xAxisObj = data.xAxisObj;
            model = data.model;
            format = data.format;

            isIndentedTree = ( (!reportMetadata.tree) && (report.type == StatementType.IS || report.type == StatementType.BS) );

            
            //forcing TB, indented IS/BS to always be flat
            if (report == StatementType.TB || isIndentedTree) {
                format = 'flat';
            }
            
            timeDisplaySettings = data.timeDisplaySettings;
            filtersApplied = data.filtersApplied;
            filtersAppliedPathMap = buildFiltersAppliedPathMap(filtersApplied, filtersAppliedPathMap, segmentNodePathMap);
            hide0Bal = data.hide0Bal;
            hideTotal = !data.hideTotal;
            segmentHierarchy = data.segmentHierarchy;    
            segmentNodePathMap = data.segmentNodePathMap;            
            segmentFlat  = data.segmentFlat ;               
            revenueGLs = data.revenueGLs;
            expenseGLs = data.expenseGLs;            
            period13mapData = data.periodmapData[0].period13mapData;           

           
            setIsFlatRollup();
            assembleData();
        }
        
        if (type === "csvExport") {
            setIsFlatRollup();
            serverTimeFormattedFile = data.serverTimeFormattedFile;
            csvExport();
        }  
        if (type === "pdfExport") {
            setIsFlatRollup();
            serverTimeFormattedFile = data.serverTimeFormattedFile;
            expandedNodesForPDF = data.expandedNodes;
            
            console.log('expandedNodesForPDF');
            console.log(expandedNodesForPDF); 
            pdfExport();
        }            
        
    }
    
    
    function setIsFlatRollup() {
        isFlatRollup = false;
        if (report.type == StatementType.TB || isIndentedTree) {
            if ('yAxisExpanded' in model) {
                if (!model.yAxisExpanded) {
                    isFlatRollup = true;
                }
            }
        }          
        console.log('isFlatRollup: ' + isFlatRollup);
    } 
    
    
//================================================================
// BEGIN query hierarchy and dimension functions
//================================================================       
    
    
    function queryHierarchy() {
        
        hierarchy = null;
        dimQueryResults = {};   
        hierachyQueryResults = {};
        
        console.log('&&&&&&&&&&&&&&&&&&&&&&& queryHierarchy OLAPconfig');
        console.log(OLAPconfig);
        
        //no need to query the hierarchy object if there aren't any custom segments
        var dims = OLAPconfig.reportMetadata.reportingDims;
        var doQuery = false;
        if (dims != null) {
            if (dims.length > 0) {
                doQuery = true;
            }
        }
        
        if (!doQuery) {
            queryHierarchyComplete();
        }
            
        //build a unique list of all the Hierarchy Names we need to query
        var hierarchyNames = [];
    
        //initialize an object to hold the results of all the dimension query results
        for (var i=0; i<dims.length; i++) {
            var dim = dims[i];
            dimQueryResults[dim.object] = {isComplete: false, recordMap: {}};
            
            if (hierarchyNames.indexOf(dim.hierarchyName) == -1) {
                hierarchyNames.push(dim.hierarchyName); //add if doesn't exist
            }
        }
        
        //initialize the object to hold the hierarchy object query
        hierachyQueryResults = {isComplete: false, records: []};

        //fire off querying the hierarchy object and the custom segment objects     

        //commenting out for rootstock
        //doHierarchyQuery(hierarchyNames);
        for (var dim in dimQueryResults) {
            if (dimQueryResults.hasOwnProperty(dim)) {
                doDimQuery(dim);
            }
        }
 
    }
    
    
    //this function checks to see if the hierachy object and all the
    //dimension objects have been retrieved.
    function checkHierDimsComplete() {
        var numComplete = 0;
        var numTotal = 0;
        
        //numTotal++; //adding one for the single hierarchy query we always do
        
        //add in the dimension object totals and complete numbers
        for (var dim in dimQueryResults) {
            if (dimQueryResults.hasOwnProperty(dim)) {
                numTotal++;
                if (dimQueryResults[dim].isComplete) {
                    numComplete++;
                }
            }
        }
        
        if (hierachyQueryResults.isComplete) {
            numComplete++;
        }
        
        if (numTotal == numComplete) {
            joinDimsToHierachy();
        }
        
    }
    
    
    function doHierarchyQuery(hierarchyNames) {
        Visualforce.remoting.Manager.invokeAction(
            '{!$RemoteAction.AnalyticsServiceCon.queryHierarchy}',
            hierarchyNames,
            function (result, event) {
                checkErrors(event);
                //console.log('doHierarchyQuery result');
                //console.log(result);
                
                if (event.status) {
                    hierachyQueryResults.isComplete = true;
                    hierachyQueryResults.records = JSON.parse(result);
                    checkHierDimsComplete();
                }
                
            },
            {escape: false, buffer: false}
        );      
    }
    
    
    function doDimQuery(dim) {
        const companyId = reportMetadata.frList[0].rifr_cmpno__c;
        Visualforce.remoting.Manager.invokeAction(
            '{!$RemoteAction.AnalyticsServiceCon.queryDim}',
            dim,
            companyId,
            function (result, event) {
                checkErrors(event);
                console.log('doDimQuery result');
                console.log(result);
                
                if (event.status) {
                    var dimObj = JSON.parse(result);
                    dimQueryResults[dimObj.dim].isComplete = true;
                    dimQueryResults[dimObj.dim].recordMap = dimObj.recordMap;
                    checkHierDimsComplete();                    
                }
            },
            {escape: false, buffer: false}
        );      
    }    
    
    function joinDimsToHierachy() {
        console.log('joinDimsToHierachy hierachyQueryResults dimQueryResults reportMetaData.reportingDims');
        console.log(hierachyQueryResults);
        console.log(dimQueryResults);
        console.log(reportMetadata.reportingDims);      
        
        //loop through the reportingDims
        for (var i=0; i<reportMetadata.reportingDims.length; i++) {
            var dim = reportMetadata.reportingDims[i];

            //see if this is a dim that needs to be connected up to the hierarchy or not
            var useHier = (dim.hierarchyName != null);
            
            if (useHier) {
                //get the corresponding query results for this dim
                var recordMap = dimQueryResults[dim.object].recordMap;                
                
                //the hierarchy records don't have the name of the dimension in them, so we have to populate that
                //from our queries of the dimension (segment objects)
                hierachyQueryResults.records.push({
                    hierarchyName   : dim.hierarchyName,
                    name            : '(Empty)',        //we need to get the name from the dim objects later
                    id              : dim.object+'_empty',
                    hId             : dim.object+'_empty',
                    parentId        : null
                })
                for (var j=0; j<hierachyQueryResults.records.length; j++) {
                    var h = hierachyQueryResults.records[j];
                    
                    //check for a match between the hierarchy id and the dimension ids
                    //we don't know which dimension object it may be in, just search until
                    //we find it
                    for (var dimName in dimQueryResults) {
                        if (dimQueryResults.hasOwnProperty(dimName)) {
                            var recordMap = dimQueryResults[dimName].recordMap;
                            if (h.id in recordMap) {
                                h.name = recordMap[h.id].name;
                                break;
                            }
                        }
                    }    
                }                
            } else {
                buildDimsNoHierarchy(dim.object);
            }
        
        }

        queryHierarchyComplete();   
    }
    
    
    
    //if we aren't using a hierarchy for this dimension, we need to loop through the 
    //the dimensions themselves and add them to the hierachy object.  we create a flat dummy
    //hierarchy on the fly
    function buildDimsNoHierarchy(dim) {
        var recordMap = dimQueryResults[dim].recordMap;
        
        var dimRecords = [];
        for (var id in recordMap) {
            if (recordMap.hasOwnProperty(id)) {
                var record = {
                    'hId'                       : id,
                    'hierarchyName'             : '____default_flat',
                    'id'                        : id,
                    'name'                      : recordMap[id].name,
                    'parentId'                  : null
                };
                dimRecords.push(record);
            }
        }
        
        //add our dummied up hierarchy records we created to the main hierarchy
        hierachyQueryResults.records = hierachyQueryResults.records.concat(dimRecords);
    }    
    
    
    
    function queryHierarchyComplete() {
        console.log('queryHierarchyComplete records');
        console.log(hierachyQueryResults.records);
        
        window.parent.postMessage({"type": "hierarchy", "hierarchy": hierachyQueryResults.records}, "*");       
    }
    
    
//================================================================
// END query hierarchy and dimension functions
//================================================================    

    

    function startChunking(data) {
        console.log('startChunking data');
        console.log(data);      
        
        var response;
        
        if ('chunksize' in data) {
            if (data.chunksize != null) {
                chunkSize = data.chunksize;
            }
        }

        keyDataMap = {};
        buildObjToDimensionsMap();
        
        for (var i=0; i<data.model.facts.length; i++) {
            chunkEntireDB(data.model.facts[i]);
        }
    }
    

    function buildObjToDimensionsMap() {
        //this will give us a shortcut to get an array of all the dimensions for an object in a model
        objToDimensionsMap = {};
        aliasToMetricMap = {};
        var aliasToObjMap = {};
        
        for (var i=0; i<model.facts.length; i++) {
            var fact = model.facts[i];
            aliasToObjMap[fact.alias] = fact.obj;
            objToDimensionsMap[fact.obj] = [];
        }        
        for (var i=0; i<model.dimensions.length; i++) {
            var fields = model.dimensions[i].fields;
            for (alias in fields) {
                if (fields.hasOwnProperty(alias)) {
                    var obj = aliasToObjMap[alias];
                    objToDimensionsMap[obj].push(fields[alias]);
                }
            }
        }    
        
        
        for (var i=0; i<model.metrics.length; i++) {
            var metric = model.metrics[i];
            if (metric.metType == 'Data') {
                var alias = metric.alias;
                
                if (!(alias in aliasToMetricMap)) {
                    aliasToMetricMap[alias] = [];
                }
                aliasToMetricMap[alias].push(metric.field);             
            }
        }            
        
        console.log('buildObjToDimensionsMap: objToDimensionsMap aliasToMetricMap');
        console.log(objToDimensionsMap);
        console.log(aliasToMetricMap);        
    }
    
    
    //=====================================
    // patching one function in the connection.js resource, so we don't get 
    // Refused to set unsafe header "User-Agent" errror
    //=====================================
    
    sforce.Transport = function(url) {
        this.url = url;
        this.connection = null;
    
        this.newConnection = function() {
            try {
                this.connection = new ActiveXObject('Msxml2.XMLHTTP');
            } catch(e) {
                try {
                    this.connection = new ActiveXObject('Microsoft.XMLHTTP');
                } catch(e) {
                    this.connection = new XMLHttpRequest();
                }
            }
    
            return this.connection;
        };
    
        this.send = function (envelope, callback, async, timeout) {
            this.newConnection();
            if (async) {
                this.connection.onreadystatechange = this.httpConnectionCallback;
            }
            var holder = new sforce.internal.ConnectionHolder(this.connection, callback);
            sforce.internal._connections.push(holder);
            this.connection.open("POST", this.url, async);
            this.connection.setRequestHeader("Content-Type", "text/xml; charset=UTF-8");
            this.connection.setRequestHeader("SOAPAction", "\"\"");
            this.connection.setRequestHeader("Accept", "text/xml");
            //this.connection.setRequestHeader("User-Agent", "SFAJAX 1.0"); //here is the one line we are patching
            this.connection.send(envelope);
            if (async && typeof(timeout) !== "undefined") {
                this.setTimeoutOn(holder, timeout);
            }
            if (!async) {
                this.httpConnectionCallback();
            }
        };
    
        this.setTimeoutOn = function (holder, timeout) {
            function abortConnection() {
                if (holder.connection.readyState !== 4) {
                    holder.timedout = true;
                    holder.connection.abort();
                }
            }
            setTimeout(abortConnection, timeout);
        };
    
        this.httpConnectionCallback = function () {
    
            for (var i = 0; i < sforce.internal._connections.length; i++) {
                var holder = sforce.internal._connections[i];
                if (holder !== null) {
                    if (holder.timedout) {
                        sforce.internal._connections[i] = null;
                        sforce.internal._connections.slice(i,1);
                        holder.callback.httpCallback("Remote invocation timed out", false);
                    } else  if (holder.connection.readyState == 4) {
                        sforce.internal._connections[i] = null;
                        sforce.internal._connections.slice(i,1);
                        var success = holder.connection.status == 200;
                        if (sforce.debug.trace) {
                            sforce.debug.log("Response : status - " + holder.connection.status);
                            sforce.debug.logXml(holder.connection.responseText);
                        }
                        if (sforce.debug.apexTrace) {
                            sforce.debug.logApex(holder.connection.responseText);
                        }
                        if (holder.connection.responseXML && holder.connection.responseXML.documentElement) {
                            holder.callback.httpCallback(holder.connection.responseXML.documentElement, success);
                        } else {
                            holder.callback.httpCallback("Remote invocation failed, due to: " + holder.connection.responseText +
                                                         " status code: ", holder.connection.status);
                        }
                    }
                }
            }
        };
    };


    //END PATCH =======================================

    function initOLAP() {
        //build our OLAP config from the model
        console.log('initOLAP model');
        console.log(JSON.parse(JSON.stringify(model)));
        
        config = buildConfigFromModel(model);
        config.keepTotals = true;
        console.log('config');
        console.log(config);
        
        //from the config, build a map of the dimension name to whether or not is a hierarchy
        //we need this later, so may as well make it easy to get to
        dimToIsHierMap = {};
        for (i=0; i<config.dimensions.length; i++) {
            var dim = config.dimensions[i];
                dimToIsHierMap[dim.field] = false;
            if ('type' in dim) {
                if (dim.type == 'hierarchy') {
                        dimToIsHierMap[dim.field] = true;
                } 
            }
        }    
        
        
        //instantiate an empty cube
        OLAPCube = lumenize.OLAPCube;
        cube = new OLAPCube(config, []);        
    }

    function reconstituteOLAP() {
        
        //the chunk size appears to be 879k, so we should be able to do 15 of them and still be under 15MB remoting size
        var numChunks = 5;
        var batchesOfIds = []; //2D array which contains our batches of <=15 Ids to get
        
        //call the remoteAction to locate all the most recent cube chunks from the Attachments
        Visualforce.remoting.Manager.invokeAction(
            '{!$RemoteAction.AnalyticsServiceCon.getAttachmentIds}',
            report.id,
            function (result, event) {
                checkErrors(event);
                console.log('reconstituteOLAP getAttachmentIds result');
                console.log(result);
                
                var batchOfIds = [];
                for (var i=0; i<result.length; i++) {
                    batchOfIds.push(result[i]);
                    if (batchOfIds.length == numChunks) {
                        batchesOfIds.push(batchOfIds);
                        batchOfIds = [];
                    }
                }
                //last batch?
                if (batchOfIds.length > 0) {
                    batchesOfIds.push(batchOfIds);
                }
                
                var attachmentObj = {};
                var batchesReceived = 0;
                
                //loop through our 2D array with all the batches of Attachment Ids and get them
                for (var i=0; i<batchesOfIds.length; i++) {
                    var batchOfIds = batchesOfIds[i];

                    Visualforce.remoting.Manager.invokeAction(
                        '{!$RemoteAction.AnalyticsServiceCon.getAttachments}',
                        batchOfIds,
                        function (result, event) {
                            checkErrors(event);
                            console.log('reconstituteOLAP getAttachments result');
                            //console.log(result); 

                            //merge this object into the bigger object
                            for (var key in result) {
                                if (result.hasOwnProperty(key)) {
                                    attachmentObj[key] = result[key];
                                }
                            }

                            batchesReceived++;
                            if (batchesReceived == batchesOfIds.length) {
                                //all batches received, assemble them
                                var sortKeys = [];
                                for (var key in attachmentObj) {
                                    if (attachmentObj.hasOwnProperty(key)) {
                                        sortKeys.push(key);
                                    }    
                                }
                                sortKeys.sort();
                                
                                var jsonCube = '';
                                for (var i=0; i<sortKeys.length; i++) {
                                    jsonCube += attachmentObj[sortKeys[i]];
                                }
                                
                                //reconstitute the cube we saved from the file attachment
                                OLAPCube = lumenize.OLAPCube;
                                cube = OLAPCube.newFromSavedState(JSON.parse(jsonCube));
                                window.parent.postMessage({"type": "cubeReady", "cubeReady": {}}, "*");                                     
                            }
                        },
                        {escape: false, buffer: false}
                    );                        
                    
                }
                
                
            },
            {escape: false, buffer: false}
        );      
    
    
    
    
    }    

    //var objectNameGlobal;
    function chunkEntireDB(fact) {

        //objectNameGlobal = objectName; //WARNING, this won't support multiple object queries
        
        chunkList[fact.obj] = [];
        objectQueriesCompleted[fact.obj] = 0;
        objectAllQueriesCompleted[fact.obj] = false;
        
        totalQueriesCompleted[fact.obj] = 0;
        
        var SOQL = ("SELECT Id FROM " + fact.obj + " ORDER BY Id");
        console.log('SOQL: '+ SOQL);
        
        var result = sforce.connection.query(SOQL, {
            onSuccess: function(result) {
                
                console.log('success');
    
                var resultValues = getResultValues(result);

                console.log('result');
                console.log(result);
                  
                console.log('resultValues');
                console.log(resultValues);
                
                var objectName = resultValues.type;     

                //add the first result to our object before we fire off all the subsequent ones in parallel
                if(resultValues.type in offsetIdMap) {
                    offsetIdMap[objectName][resultValues.offset] = resultValues; 
                } else {    
                    offsetIdMap[objectName] = {};
                    offsetIdMap[objectName][resultValues.offset] = resultValues; 
                }
        
            
                if (resultValues.totalSize <= 2000) {
                    //this means there is no cursor Id, we got all the records returned to us
                    //chunk is just the first and last Id in the locator, jump right to success
                    totalQueryMoreSize[objectName] = 1;
                    qmSuccess(result);                  
                } else {
                    //> 2000 records means that we need to chunk
                    
                    //get the loop size
                    var loopSize = Math.floor(resultValues.totalSize / chunkSize);
                    
                    //we need to know ahead of time how many times we are going to call doQueryMore, so when the 
                    //results come back async, we know if we are done or not
                    totalQueryMoreSize[objectName] = loopSize;
            
                    //in case it didn't divide evenly, will have to fire off one more query of a custom size
                    //the offset will be the total number of records in the querylocator minus the leftover
                    //EX: 100,002, R=2, offset = 100,002 - 2 = 100,000
                    var remainder = resultValues.totalSize % chunkSize;     
                    
                    //in some cases we don't need another queryMore for the remainder.
                    //if total records - running total is less than chunk size, the last id query will get us everything
                    var runningTotal = (chunkSize * loopSize);
                    if ((resultValues.totalSize - runningTotal) < chunkSize) {
                        remainder = 0;
                    }
                    
                    //if the chunks divide perfectly into the totalSize, subtract one from the loopsize
                    //otherwise we will be requesting an offset that doesn't exist at the end.
                    if ((resultValues.totalSize - runningTotal) == 0) {
                        loopSize--;
                        totalQueryMoreSize[objectName]--;
                    }
                    
                    if (remainder > 0) {
                        totalQueryMoreSize[objectName] ++;
                    }   
                
                    //add in one more for the query of the last Id
                    totalQueryMoreSize[objectName] ++;
            
                    //fire off all the queryMore's for loopSize
                    for (var i=1; i<=loopSize; i++) {
                        var offset = chunkSize * i;
                        doQueryMore(resultValues.cursorId, offset); 
                    } 
                    
                    //fire off one more if there was a remainder
                    if (remainder > 0) {
                        var offset = (resultValues.totalSize - remainder);
                        doQueryMore(resultValues.cursorId, offset);     
                    }               
            
                    //now fire off one more to get the last Id in the cursor
                    var offset = (resultValues.totalSize - 1);
                    doQueryMore(resultValues.cursorId, offset);                     
                }

            
            },
            onFailure: function(error) {
                var qErr = {};
                qErr.status = false;
                qErr.type = 'exception';
                qErr.message = 'Problem getting query locator: ' + error;

                checkErrors (qErr);                 
            }, 
            timeout: AJAXtimeout
        });     
        


    }

    function doQueryMore(cursorId, offset) {
        var ql = cursorId + '-' + offset;
        console.log('queryMore ql');
        console.log(ql);
        sforce.connection.queryMore(ql, {
            onSuccess: qmSuccess,
            onFailure: queryError,
            timeout: AJAXtimeout
        });
    }
    
    function qmSuccess(result) {
    
        //console.log('result');
        //console.log(result);      
        
        var resultValues = getResultValues(result);


        console.log('resultValues');
        console.log(resultValues);  
        
        if (resultValues.type in offsetIdMap) {
            offsetIdMap[resultValues.type][resultValues.offset] = resultValues; 
        } else {    
            offsetIdMap[resultValues.type] = {};
            offsetIdMap[resultValues.type][resultValues.offset] = resultValues; 
        }
        totalQueriesCompleted[resultValues.type] ++;

        console.log(totalQueryMoreSize[resultValues.type] + ', ' + totalQueriesCompleted[resultValues.type]);
        if (totalQueryMoreSize[resultValues.type] == totalQueriesCompleted[resultValues.type]) {
            allQueriesComplete(resultValues.type);
        }
    }

    function queryError(error) {
        var qErr = {};
        qErr.status = false;
        qErr.type = 'exception';
        qErr.message = 'error';
        
        checkErrors (qErr);
    }

    function getResultValues(result) {
        var retObj = {};
        retObj.totalSize = -1;
        retObj.cursorId = '';
        retObj.offset = 999999999999; //~1T records.  using this to put last result at the end of the sort, its QL will be null
        retObj.firstRecordId = '';
        retObj.lastRecordId = '';
        retObj.type = '';
        
        //get the querylocator from the result
        var ql = result.queryLocator;
        
        //ql will look like this:
        //01gJ000000IYnYLIA1-2000
        
        //split the ql into cursorId and offset
        if (ql != null) { //if there are no more records to get, ql will be null
            var arrQL = ql.split('-');
            if (arrQL.length == 2) {
                retObj.cursorId = arrQL[0];
                retObj.offset   = arrQL[1];
            }   
        }

        
        //get the total size, convert to int
        retObj.totalSize = parseInt(result['size']);        
        
        //get the first record Id
        var firstRecordFound = false;
        if ('records' in result) {
            //see if it is in an array
            if (Object.prototype.toString.call(result.records) === '[object Array]') {
                if (result.records.length > 0) {
                    retObj.firstRecordId = result.records[0].Id;
                    retObj.type = result.records[0].type;
                    firstRecordFound = true;
                }           
            } else {
                //or else just a single object
                if ('Id' in result.records) {
                    retObj.firstRecordId = result.records.Id;
                    retObj.type = result.records.type;
                    firstRecordFound = true;                
                }
            }
        }
        
        //get the last record Id
        var lastRecordFound = false;
        if ('records' in result) {
            //see if it is in an array
            if (Object.prototype.toString.call(result.records) === '[object Array]') {
                if (result.records.length > 0) {
                    retObj.lastRecordId = result.records[result.records.length-1].Id;
                    lastRecordFound = true;
                }           
            } else {
                //or else just a single object
                if ('Id' in result.records) {
                    retObj.lastRecordId = result.records.Id;
                    lastRecordFound = true;             
                }
            }
        }

        //WARNING: this won't support multiple objects
        if (retObj.type == '') {
            console.log('FIX ME!  Need to handle when there is no data');
            //retObj.type = objectNameGlobal;
        }
        
        return retObj;
    }




    function allQueriesComplete(type) {
        
        //build an array of all the keys so we can sort them
        var offsetArray = [];
        for (var offset in offsetIdMap[type]) {
            offsetArray.push(parseInt(offset));
        }
                                            
        offsetArray.sort(function(a,b) { return a - b; });
        
        //loop from the beginning to the next to last one
        //don't need the last since it just contains the very last Id - special case
        
        if(offsetArray.length==1) {
            var range = {};
            
            range.first = offsetIdMap[type][offsetArray[0]].firstRecordId;
            range.last = offsetIdMap[type][offsetArray[0]].lastRecordId;
            range.isLast = true;
            chunkList[type].push(range);
            
        } else {
            
            for (var i=0; i<(offsetArray.length-1); i++) {
                var range = {};
                range.first = '';
                range.last = '';
                range.isLast = false;
                
                var currOffset = offsetArray[i];
                var nextOffset = offsetArray[i+1];
                range.first = offsetIdMap[type][currOffset].firstRecordId;
            
                var lastLoop = false;
                if (i == (offsetArray.length-2)) {
                    lastLoop = true;
                }
    
                if (lastLoop) {
                    range.isLast = true;
                    
                    //the last Id will be the actual last Id from the very last chunk
                    range.last  = offsetIdMap[type][nextOffset].lastRecordId;
                } else {
                    //the last Id will be the first from the next chunk (have to use < logic)
                    range.last  = offsetIdMap[type][nextOffset].firstRecordId;          
                }
                chunkList[type].push(range);
                
            }
        }
        
        
        
        console.log('chunkList');
        console.log(chunkList);

        console.log('*** QLPK done***');    
        
        
        //chunkListGlobal = chunkList[type];
        
        //now kick off the chunk queries
        parallelStart(type);

    }       
        



    //=========================================================
    // BEGIN Query Chunks
    //=========================================================

            
    
    //TODO: make these variables we can pass in
    var numSimultaneous = 1000;
    var numberOfRetries = 20;
    
    var chunkRetries = {};
    var startTimestamp = {};        
    
    var numTotal = {};
    var numRemainingTotal = {};
    var numRemainingBatch = {};
    //var allRecords = {};
    var allRecordsReceived = {};
    var keyDataMap = {};
    
    
    function parallelStart(type) {
        console.log('parallelStart: ' + type);
        console.log('chunkList');
        console.log(chunkList);

        numTotal[type] = chunkList[type].length;
        numRemainingTotal[type] = numTotal[type];
        numRemainingBatch[type] = 0;
        //allRecords[type] = {};
        allRecordsReceived[type] = false;

        getNextBatch(type);
    }       
    
    function getNextBatch(type) {
        console.log('getNextBatch type: ' + type);
        console.log('getNextBatch numRemainingBatch: ');
        console.log(numRemainingBatch);             
        
        /*
        console.log('getNextBatch numTotal[type]');
        console.log(numTotal[type]);

        console.log('getNextBatch numRemainingBatch[type]');
        console.log(numRemainingBatch[type]);    
        */
        
        if (numRemainingTotal[type] == 0) {
            parallelEnd(type);
        } else {
            var nextBatchStartIndex = numTotal[type] - numRemainingTotal[type];
            
            //get the number of simultaneous chunks, or whatever is left if it's less
            numRemainingBatch[type] = numSimultaneous;
            if (numRemainingTotal[type] < numRemainingBatch[type]) {
                numRemainingBatch[type] = numRemainingTotal[type];
            }                       
            chunkWorker(nextBatchStartIndex, numRemainingBatch, type);
        }
    }       
    
    function chunkWorker(nextBatchStartIndex, numRemainingBatch, type) {
        for (var i=0; i<numRemainingBatch[type]; i++) {
            updateStatus(1, 'Data Requested ('+type+'): ' + (nextBatchStartIndex+i+1) + '/' + numTotal[type] +  '. ');              
            getChunk(nextBatchStartIndex+i, type);
        }       
    }    
    
    function chunkComplete(context, event, response) {
        console.log('**** chunkComplete context, event, response');
        console.log(context);
        console.log(event);
        console.log(response);        

        var type = context.type;
        var result = response.objects;
        //gltxnsum__c KNDY4__Accounting_Entry_Line__c

        console.log('Obj Type:');
        console.log(type);
        if (type == 'gltxnsum__c') {
            result = processAELresult(result);
        }
        
        numRemainingBatch[type]--;
        numRemainingTotal[type]--;
        updateStatus(2, 'Received ('+type+'): ' + (numTotal[type]-numRemainingTotal[type]) + '/' + numTotal[type] + '.');
    
        //add the data to the master data object
        addData(result, type);          
            
        if (numRemainingBatch[type] == 0) {
            getNextBatch(type);
        }
    }       
    
    function processAELresult(records) {
        var resultsBalance = [];
        var reportType = report.type;

        console.log('Report Type:');
        console.log(reportType);

        for (var i=0; i<records.length; i++) {
            
            var record = records[i];    
            var contra = resolveValue(record, contraFieldName);
            var normalBal = resolveValue(record, 'gltxnsum_glacct__r.glacct_cfr_gl_type__r.gltype_normalbal__c');
            var stmtType = resolveValue(record, 'gltxnsum_glacct__r.glacct_cfr_gl_type__r.gltype_glstmttype__c');
            var cashFlowSection = resolveValue(record, 'gltxnsum_glacct__r.glacct_cfr_section_grouping__c');
            var glType = resolveValue(record, 'gltxnsum_glacct__r.glacct_cfr_gl_type__r.Name');
            var accountingtype = resolveValue(record, 'gltxnsum_glacct__r.glacct_cfr_gl_type__r.gltype_accttype__c');
            var DR = resolveValue(record, 'gltxnsum_dramt__c');
            var CR = resolveValue(record, 'gltxnsum_cramt__c');  
            
            /*
            //FUTURE: If we relax Asset GL Types to be CR, and Revenue GL Types to be DR
            //we will need to do this logic
            //if the contra belongs to a GL type where it also includes non-contras, "uncheck" the contra flag
            var glTypeId = resolveValue(record, 'KNDY4__GL_Account__r.KNDY4__GL_Type__c');
            if ( (!(glTypeId in mixedContraGLtypes)) && contra) {
                if (normalBal == 'Debit') {
                    normalBal = 'Credit';
                } else {
                    normalBal = 'Debit';
                }                
            }
            */
            
            //functional currency balance
            var balanceFunct = calcBalance(DR, CR, normalBal, contra, reportType, stmtType, cashFlowSection, glType, accountingtype);

            console.log('Balance Calc:');
            console.log(balanceFunct);

            if (reportType == StatementType.MCTB) {
                //functional balance
                record['funct_bal'] = balanceFunct;
                
                //transactional balance
                var DRtrans= resolveValue(record, 'KNDY4__COMP_Transaction_Currency_Amount_DR__c');
                var CRtrans = resolveValue(record, 'KNDY4__COMP_Transaction_Currency_Amount_CR__c');                  
                var balanceTrans = calcBalance(DRtrans, CRtrans, normalBal, contra, reportType, stmtType, cashFlowSection, glType, accountingtype);
                record['trans_bal'] = balanceTrans;
            } else {
                //functional balance
                record['Balance_f__c'] = balanceFunct;
            }

            console.log('Balance_f__c:');
            console.log(record['Balance_f__c']);

            resultsBalance.push(record);
        }
        
        return resultsBalance;
    }
    
    
    function calcBalance(DR, CR, normalBal, contra, reportType, stmtType, cashFlowSection, glType, accountingtype) {
        DR = (DR == null ? 0 : DR);
        CR = (CR == null ? 0 : CR);
        
        var DRbalance = (normalBal == 'Debit');        
        
        //pre fall 2016 - normalBal comes from the GL type field.  account and contra account have different normal balances
        //if ((!useGLcontra) && contra) {
        if(contra){
            DRbalance = !DRbalance;
        }
        
        //for trial balance we are always going to do DRbalance (DR - CR)
        if (reportType == StatementType.TB || reportType == StatementType.MCTB) {
            DRbalance = true;
        }
        
        var balance = 0;
        if (DRbalance) {
            balance = DR - CR;
        } else {
            balance = CR - DR;    
        }
        
        if (reportType == StatementType.CF && (stmtType == StatementType.BS && DRbalance) && cashFlowSection != 'Cash') {
            balance *= -1;
        } 

        // todo accouting-type = 'otherincome expense ' and normalbalance = 'debit' and stmtype = 'is'
        if (reportType == StatementType.IS && (accountingtype == 'Other Income (Expense)' && normalBal == 'Debit')) {
           balance *= -1;
        }   
        
        return balance;
    }
    
    function parallelEnd() {
    }                 
    
    function addData(result, type) {
        //get the alias from the object
        var alias;
        for (var i=0; i<model.facts.length; i++) {
            var fact = model.facts[i];
            if (fact.obj == type) {
                alias = fact.alias;
                break;
            }
        }
        
        for (var i=0; i<result.length; i++) {
            var record = result[i];
            var recordKey = getRecordKey(type, record);          
            record = aliasRecord(alias, record);
            
            //console.log('&&&&&&&&& recordKey:' + recordKey);
            //console.log('&&&&&&&&& record:');
            //console.log(record);
            
            if (!(recordKey in keyDataMap)) {
                keyDataMap[recordKey] = {};
            }
            
            //add the metric fields in the record to the master data map
            for (var met in record) {
                if (record.hasOwnProperty(met)) {
                    if (record[met] != null) {
                        if (!(met in keyDataMap[recordKey])) {
                            keyDataMap[recordKey][met] = 0;
                        }  
                        keyDataMap[recordKey][met] += record[met];
                    }
                }
            }
        }   
        if (numRemainingTotal[type] == 0) {
            dataComplete(type);
        }             
    }

    //turns the dimension names into the common objName with no alias
    //aliases the metrics so names don't conflict
    function aliasRecord(alias, record) {
        
        /*
        console.log('aliasRecord alias: ' + alias + ', record: ');
        console.log(record);

        console.log('aliasRecord aliasToMetricMap: ');        
        console.log(aliasToMetricMap);          
        */
        
        var aRec = {};
        //loop over the dimensions and normalize the names to the common name
        for (var i=0; i<model.dimensions.length; i++) {
            var dim = model.dimensions[i];
            aRec[dim.objName] = resolveValue(record, dim.fields[alias]);
        }
        
        //loop over the metrics for this object alias
        for (var i=0; i<aliasToMetricMap[alias].length; i++) {
            var met = aliasToMetricMap[alias][i];
            aRec[alias+'_'+met] = resolveValue(record, met);
        }        
        return aRec;
    }
    
    
    function getRecordKey(type, record) {
        var recordKey;
        var dimVals = [];
        var allDimsForObj = objToDimensionsMap[type];
        for (var i=0; i<allDimsForObj.length; i++) {
            dimVals.push(resolveValue(record, allDimsForObj[i]));
        }
        recordKey = dimVals.join('|');
        
        return recordKey;
    }
    
    function dataComplete(type) {
        allRecordsReceived[type] = true;

        //one of the objects of data has all records received.  let's see if all objects in the model have all records received.
        var allComplete = true;
        for (var i=0; i<model.facts.length; i++) {
            var modelObj = model.facts[i].obj;
            if (modelObj != type) {
                var modelObjComplete = false;
                if (modelObj in allRecordsReceived) {
                    modelObjComplete = allRecordsReceived[type];
                }
                if (!modelObjComplete) {
                    allComplete = false;
                    break;
                }
            }
        }        
        console.log('dataComplete type:' + type + ', allComplete: ' + allComplete);
        
        if (allComplete) {
            allDataReceived();
        }
    }
    
    
    
    
    function allDataReceived() {
        console.log('*********** allDataReceived keyDataMap');
        console.log(keyDataMap);
        //convert the data map we used to compact the data and do the full join
        //into an array of records
        
        var records = [];
        for (var recordKey in keyDataMap) {
            if (keyDataMap.hasOwnProperty(recordKey)) {
                var record = keyDataMap[recordKey];
                
                //deconstruct the recordKey into the dimensions
                //and add them as properties with the proper name to the record
                var arrKey = recordKey.split('|');
                for (var i=0; i<model.dimensions.length; i++) {
                    var dim = model.dimensions[i];
                    
                    var key = arrKey[i];
                    if (key == '') {
                        key = null;
                    }
                    record[dim.objName] = key;
                }    
                
                records.push(record);
            }
        }
            
        buildFacts(records);
    }
  
    function buildFacts(records) {
        //console.log('((((((((((((((((((((((((  processFacts facts');
        //console.log(facts);
        
        //console.log('processFacts segmentNodePathMap');
        //console.log(segmentNodePathMap);
        
        updateStatus(3, 'Processing data, please be patient.');     
        
        //loop through each query result and build a fact with the dimensions and metrics
        //something like this:  
        //{ProjectHierarchy: [1, 2, 3], Priority: 1, Points: 10},
        //and add it to the cube
        
        var counter = 0;
        var batchCounter = 1;
        
        var facts = [];
        
        for (var i=0; i<records.length; i++) {
            totalFacts++;
            counter++;
            var fact = buildFactWorker(records[i], facts);
            if (fact != null) {
                facts.push(fact);
            }
        }
        
        factsComplete(facts);
         
    }
    
    
    function buildFactWorker(record) {
        var model = OLAPconfig.model;
        
        var fact = {};
        var addFact = true;
        
        for (var j=0; j<model.dimensions.length; j++) {
            var dim = model.dimensions[j].objName;
            //Adding dim+'_empty' to resolve if any empty placeholder for segments
            var dimVal = safeName(resolveValue(record, dim, dim+'_empty'));
            var dimValToUse;
            
            if (dimVal != null) {
                if (model.dimensions[j].hierarchy) {
                    //console.log('processFacts dim: '+ dim);
                    var dimValAndParentsArray = segmentNodePathMap[dim][dimVal];
                    dimValToUse = dimValAndParentsArray;        
                } else {
                    dimValToUse = dimVal;
                }                
            }
            
            if (dimValToUse == null) {
                console.log('*** processFacts NULL dimension: ' + dim + ', ' + JSON.stringify(record));
                addFact = false;
            }
            fact[dim] = dimValToUse;
        }
        
        for (var j=0; j<model.metrics.length; j++) {
            if (model.metrics[j].metType == 'Data') {
                var metric = model.metrics[j].alias + '_' + model.metrics[j].field;
                var metricVal = resolveValue(record, metric);
                
                fact[metric] = metricVal;            
            }
        }   
        
        if (!addFact) {
            fact = null;
        }
        
        return fact;
    }

    
    function pad(num, size) {
        var s = num+"";
        while (s.length < size) s = "0" + s;
        return s;
    }    
    
    function saveCube(sCube) {
        //console.log('saveCube');
        //console.log(sCube);
        
        jsonCube = JSON.stringify(sCube);
        
        //25MB is our max file size, but I don't think we can't pass that to a RemoteAction
        //UTF-8 should be 25M chars for 25MB, UTF-16 should be 12.5M chars
        //biggest RemoteAction can take is 1M
        var charsInChunk = 900000;

        var chunkCounter = 0;
        
        //get server timestamp for filename
        Visualforce.remoting.Manager.invokeAction(
            '{!$RemoteAction.AnalyticsServiceCon.getGMTtimestamp}',
            function (result, event) {
                checkErrors(event);
                if (event.status) {
                    var GMTtimestamp = result;
                    console.log('saveCube getGMTtimestamp: ' + GMTtimestamp);

                    for (var i=0, charsLength = jsonCube.length; i < charsLength; i += charsInChunk) {
                        console.log('*** saveCube: ' + i);
                        var jsonCubeChunk = jsonCube.substring(i, i + charsInChunk);
                        //console.log(chunk);
                        var sName = GMTtimestamp + '|' + pad(chunkCounter, 4);
                        
                        Visualforce.remoting.Manager.invokeAction(
                            '{!$RemoteAction.AnalyticsServiceCon.createAttachment}',
                            report.id, jsonCubeChunk, sName,
                            function (result, event) {
                                checkErrors(event);
                            },
                            {escape: false, buffer: false}
                        );  
                        chunkCounter++;
                    }        

                    
                }    
            },
            {escape: false, buffer: false}
        );            
        
    }
    
    function factsComplete(facts) {
        console.log('factsComplete facts');
        //console.log(facts);
        
        //create a web worker to create the OLAP cube on a separate thread
        var lumenizeURL = '{!$Resource.rstkf__lumenize}';
        var ow = new Worker('{!$Resource.OLAPworker }');

        ow.addEventListener('message', function(e) {
            //console.log('OLAP Worker message: ', e.data);
            console.log('WORKER cube');
            //console.log(e);
            
            var sCube = e.data;
            console.log('sCube');
            console.log(sCube);
            
            
            //COMMENTED OUT BELOW TO TURN OFF CUBE CACHING FOR NOW
            //fire off an async function to save the cube, we don't want this to block anything
            //setTimeout(function() {
            //    saveCube(sCube);
            //}, 0);            
            

            var cubeReadyData = {};

            cube = OLAPCube.newFromSavedState(sCube);
            window.parent.postMessage({"type": "cubeReady", "cubeReady": cubeReadyData}, "*"); 
            
        }, false);
        
        ow.addEventListener('error', function(e) {
            console.log('OLAP Worker error: ', e.data);
        }, false);        
        
        var workerObj = {'lumenizeURL': lumenizeURL, 'config': config, 'facts': facts};
        workerObj = JSON.stringify(workerObj);
        
        ow.postMessage(workerObj);
        
        console.log('factsComplete: ' + totalFacts);
    }

    
    function deleteOldAttachments() {
        //COMMENTING OUT FOR NOW
        //SINCE CUBE CACHING IS DISABLED
        
        /*
        //query for existing attachments
        var SOQL =  "SELECT Id " +
                    "FROM Attachment " +
                    "WHERE ParentId = '" + + "' " +
                    "AND Name='Report_Cache' " +
                    "ORDER BY CreatedDate DESC";

        var result = sforce.connection.query(SOQL, {
            onSuccess: function(result) {
                console.log('factsComplete success result');
                console.log(result);
                var records = result.getArray("records");

                if (records.length > 1) {
                    var deleteIds = [];
                    for (var d=0; d<records.length; d++) {
                        deleteIds.push(records[d].Id);
                    }
                    
                    
                }                
            },
            onFailure: function(error) {
                var qErr = {};
                qErr.status = false;
                qErr.type = 'exception';
                qErr.message = 'query cached attachments error: ' + error;
                checkErrors (qErr);                 
            }, 
            timeout: AJAXtimeout
        });             
        


        //delete the existing attachments        
        var delResult = sforce.connection.deleteIds(deleteIds, {
            onSuccess: function(result) {
                
            },
            onFailure: function(error) {
                var qErr = {};
                qErr.status = false;
                qErr.type = 'exception';
                qErr.message = 'delete cached attachments error: ' + error;
                checkErrors (qErr);                     
            }, 
            timeout: AJAXtimeout
        });         
        */
        
        
        
    }
    
    
    
 function getChunk(startAt, type) {
        var firstId = chunkList[type][startAt].first;
        var lastId  = chunkList[type][startAt].last;
        var isLast  = chunkList[type][startAt].isLast;

        var context = {'type': type, 'num': startAt};
        
        var remoteCallback = function (result, event) {
            handleRemoteResponse(this, result, event);
        }            
        var remoteCallbackWithContext = remoteCallback.bind(context);    

        Visualforce.remoting.Manager.invokeAction(
            '{!$RemoteAction.AnalyticsServiceCon.queryFactsChunk_v2}',
            JSON.stringify(OLAPconfig.model), firstId, lastId, isLast, type,
            remoteCallbackWithContext,
            {escape: false, buffer: false}
        );           
    }            
    
    
    
    function handleRemoteResponse(context, result, event) {
        //parsing result because we removed namespace from apex code, so it returns string
        result.objects = JSON.parse(result.objects);
        
        console.log('handleRemoteResponse context result event');
        console.log(context);
        console.log(result);
        console.log(event);   
        
        var type = context.type;
        var startAt = context.num;
        
        //trap any timeouts, etc.  see if we need to retry.
        var doRetry = checkRetry(event);                    
        if (doRetry == false) {
            checkErrors(event);
        }                   
        
        if (event.status) {
            chunkComplete(context, event, result);
        }
        
        if (doRetry) {
            if (!(startAt in chunkRetries)) {
                chunkRetries[startAt] = 0;
            }
            chunkRetries[startAt]++;
            
            if (chunkRetries[startAt] <= numberOfRetries) {
                console.log('retry: ' + chunkRetries[startAt]);
                getChunk(startAt, type);
            } else {
                //we hit our number of retries, time to fail
                var retryError = {};
                retryError.status = false;
                retryError.type = 'exception';
                retryError.message = 'Maximum number of database query retries (' + numberOfRetries + ') reached.  Please refresh and try again.';
                checkErrors (retryError);                       
                chunkComplete(context, result, event);                        
            }
            
        }            
        
        
    }
    
    
        function checkRetry(event) {
            var doRetry = false;
            if (event.type === 'exception') {
                if ((event.message.indexOf("timeout") > -1) ||
                    (event.message.indexOf("UNABLE_TO_LOCK_ROW") > -1) || 
                    (event.message.indexOf("ConcurrentPerOrgApex") > -1) || 
                    (event.message.indexOf("Remoting request invalid for your session") > -1) || 
                    (event.message.indexOf("Logged in") > -1)) {
                    doRetry = true; 
                }   
            }  
            return doRetry;     
        }       
    

    
    //=========================================================
    // END Query Chunks
    //=========================================================

  
    
    //=========================================================
    // BEGIN CSV Export
    //=========================================================    
    var csvRows;
    var csvYaxisPathMap;
    var csvNodeIdToNodeMap;
    var maxYdepth;
    function csvExport() {
        csvRows = [];
        csvYaxisPathMap = {};
        csvNodeIdToNodeMap = {};
        maxYdepth = 0;
        
        console.log('csvExport report');
        console.log(report);
        
        console.log('csvExport reportMetadata');
        console.log(reportMetadata);        
        
        
        console.log('csvExport asmRep');    
        console.log(asmRep);

        csvYaxisPathMap = buildHierarchyLevelParentsMap(asmRep);
        console.log('recurseAndBuildCSV csvYaxisPathMap');        
        console.log(csvYaxisPathMap);         

        getMaxYdepth(csvYaxisPathMap);
        console.log('recurseAndBuildCSV maxYdepth');        
        console.log(maxYdepth);            
        
        recurseAndBuildCSVnodeIdToNodeMap(asmRep, dispXaxisObj);
        console.log('recurseAndBuildCSV csvNodeIdToNodeMap');        
        console.log(csvNodeIdToNodeMap);           
        
        addheaderRow();
        
        recurseAndBuildCSV(asmRep, dispXaxisObj);

        console.log('recurseAndBuildCSV csvRows');
        console.log(csvRows);
        
        console.log('recurseAndBuildCSV dispXaxisObj');
        console.log(dispXaxisObj);        

        var csvString = csvRows.join("\n");
        
        window.parent.postMessage({"type": "csv", "csv": csvString}, "*");    
    }
    
    

    //build a map of the node Id to the nodes
    function recurseAndBuildCSVnodeIdToNodeMap(node, dispXaxisObj) {
        if ('id' in node) {
            csvNodeIdToNodeMap[node.id] = node;
        }
        if ('children' in node) {
            for (var i=0; i<node.children.length; i++) {
                var n = node.children[i];
                //recursively call this function again
                recurseAndBuildCSVnodeIdToNodeMap(n, dispXaxisObj);
            }
        }
    }    
    
    //get the size of the largest array in the path map.  this is our max y depth.
    function getMaxYdepth(csvYaxisPathMap) {
        for (var id in csvYaxisPathMap) {
            if (csvYaxisPathMap.hasOwnProperty(id)) {
                var arrPath = csvYaxisPathMap[id];
                if (arrPath.length > maxYdepth) {
                    maxYdepth = arrPath.length; 
                }
            }
        }
    }
        
    function addheaderRow() {
        var csvRow = [];
        
        //get the y axis title for the header row
        //add in the column for the yAxis (could be more than one dim in it)
        var yAxisArr = getAxisDimension('y', model);   
        
        if (isIndentedTree) {
            //tree view gets the y axis dims CSV separated into the same cell
            var yTitles = [];
            for (var i=0; i<yAxisArr.length; i++) {
                var a = yAxisArr[i];
                yTitles.push(a.title);
            }   
            var yTitle = yTitles.join(', ');
            csvRow.push(escapeCSVcell(yTitle));    
        } else {
            for (var i=0; i<yAxisArr.length; i++) {
                var a = yAxisArr[i];
                csvRow.push(escapeCSVcell(a.title));            
            }               
        }

        //add in the trans/funct currency header cols  
        if (report.type == StatementType.MCTB) {        
            csvRow.push('T Curr');
            csvRow.push('F Curr');
        }

        var doPad = false;
        //pad all reports which aren't trial balance
        if (report.type != StatementType.TB && report.type != StatementType.MCTB) {
            doPad = true;
        }
        //pad the trial balance if it is the grid version (non-tree)
        if (report.type == StatementType.TB && !reportMetadata.tree) {
            doPad = true;
        }        
        
        //don't pad the rolled up TB
        if (isFlatRollup) {
            doPad = false;
        }           
        
        if (doPad) {
            //pad any remaining cells if the hierarchy is deeper than the 1 title column
            var cellsToAdd = (maxYdepth - 1);
            for (var i=0; i<cellsToAdd; i++) {
                csvRow.push('');
            }               
        }

        //now add in the x axis titles
        for (var i=0; i<dispXaxisObj.values.length; i++) {
            var xAxisVal = dispXaxisObj.values[i];
            if (!xAxisVal.hidden) {
                csvRow.push(escapeCSVcell(xAxisVal.name));
            }
        }        
        csvRows.push(csvRow);
    }
    
    function recurseAndBuildCSV(node, dispXaxisObj) {
        var csvRow = [];

        //build up the y axis hierarchy columns
        if ('id' in node) {

            var supressNode = false;
            if (isFlatRollup) {
                supressNode = true;
                if ('isTopParent' in node) {
                    if (node.isTopParent) {
                        supressNode = false;
                    }    
                }
                if ('type' in node) {
                    //total nodes which aren't the grand total
                    if ( (node.type == 'Total') && (node.id != 'totalRoot_total') ){
                        supressNode = true;
                    }
                }
            }           

            var arrPath = csvYaxisPathMap[node.id];
            
            for (var i=0; i<arrPath.length; i++) {

                if (report.type == StatementType.TB && i==0 && (reportMetadata.tree || isFlatRollup)) {
                    continue; //don't add outer 'Total' node for TB in tree mode
                }                

                var nodeName = csvNodeIdToNodeMap[arrPath[i]].name;

                if ( (nodeName == 'Total Total' && report.type == StatementType.TB && (reportMetadata.tree || isFlatRollup)) || (nodeName == "Total undefined") ) {
                    nodeName = 'Total';
                }                      
                
                csvRow.push(escapeCSVcell(nodeName));
                
                if (report.type == StatementType.MCTB) {
                    //split the trans/funct currencies off of the node Id and push them in as cells
                    var transCurrency = '';
                    var functCurrency = '';
                    var yAxisDimValArr = node.id.split('_');
                    if (yAxisDimValArr.length > 1) {
                        var transFuncArr = yAxisDimValArr[1].split('/');
                        if (yAxisDimValArr.length == 2) {
                            transCurrency = transFuncArr[0];
                            functCurrency = transFuncArr[1];                    
                        }
                    }  
                    csvRow.push(escapeCSVcell(transCurrency));
                    csvRow.push(escapeCSVcell(functCurrency));
                }
            }
            
            
            var doPad = false;
            //pad all reports which aren't trial balance
            if (report.type != StatementType.TB && report.type != StatementType.MCTB) {
                doPad = true;
            }
            //pad the trial balance if it is the grid version (non-tree)
            if (report.type == StatementType.TB && !reportMetadata.tree) {
                doPad = true;
            }        
        
            //don't pad the rolled up TB
            if (isFlatRollup) {
                doPad = false;
            }                    
            
            if (doPad) {
                //pad any remaining cells if the hierarchy isn't as deep as the deepest
                var cellsToAdd = (maxYdepth - csvRow.length);
                for (var i=0; i<cellsToAdd; i++) {
                    csvRow.push('');
                } 
            }

            //loop through the dispXaxisObj and add all the remaining cells in for this row.
            for (var i=0; i<dispXaxisObj.values.length; i++) {
                var xAxisVal = dispXaxisObj.values[i];
                if (!xAxisVal.hidden) {
                    var dataId = xAxisVal.id;
                    if ( (node.type == 'Total') || isFlatRollup ) {
                        dataId += '__RU'; //if it's a totals node, use the rollup number
                    }
                    
                    // Formatting numbers to 2 decimal places while exporting to csv
                    csvRow.push(escapeCSVcell(kendo.toString(node.data[dataId], pdfNumFormat)));
                }
            }
            
            
            var addNode = false;
            
            if (!supressNode) {
                if (!(report.type == StatementType.TB && node.id == 'totalRoot' && !reportMetadata.tree)) {
                    addNode = true;
                }            
            }

            if ( (node.id == 'totalRoot_total') && isFlatRollup ) {
                addNode = true;
            }            
            
            if (addNode) {
                csvRows.push(csvRow);   
            }    
        }
        
        if ('children' in node) {
            for (var i=0; i<node.children.length; i++) {
                var n = node.children[i];
                //recursively call this function again
                recurseAndBuildCSV(n, dispXaxisObj);
            }
        }
    }    
    //=========================================================
    // END CSV Export
    //=========================================================        
    
    
    
    
    
    
    
    //=========================================================
    // BEGIN PDF Export
    //=========================================================        
    var pdfRows;
    var pdfYaxisPathMap;
    function pdfExport() {
        pdfRows = [];

        console.log('pdfExport report');
        console.log(report);

        console.log('pdfExport asmRep');    
        console.log(asmRep);

        pdfYaxisPathMap = buildHierarchyLevelParentsMap(asmRep);
        console.log('pdfExport pdfYaxisPathMap');        
        console.log(pdfYaxisPathMap);         
        

        console.log('recurseAndBuildPDF dispXaxisObj');
        console.log(dispXaxisObj);       

        
        //add the header row
        addPDFheaderRow();
        
        //lookhere
        if (isIndentedTree) {
            buildPDFIndented(repForPresentation, dispXaxisObj);
        } else if (reportMetadata.tree) {        
            recurseAndBuildPDFtree(asmRep, dispXaxisObj);
        } else {
            recurseAndBuildPDFflat(asmRep, dispXaxisObj);        
        }
        
        console.log('recurseAndBuildPDF pdfRows');
        console.log(pdfRows);
        
        window.parent.postMessage({"type": "pdf", "pdf": pdfRows}, "*");    

    }

    
    
    function addPDFheaderRow() {
        var pdfRow = {};
        pdfRow.indent = 0;
        pdfRow.cells = [];        
        
        //get the y axis title for the header row
        //add in the column for the yAxis (could be more than one dim in it)
        var yAxisArr = getAxisDimension('y', model);   
        
        
        if (reportMetadata.tree || isIndentedTree) {
            //tree view gets the y axis dims CSV separated into the same cell
            var yTitles = [];
            for (var i=0; i<yAxisArr.length; i++) {
                var a = yAxisArr[i];
                yTitles.push(a.title);
            }   
            var ycell = {};
            ycell.d = yTitles.join(', ');
            ycell.t = 0; //0=segment, 1=data.  used this method to keep the JSON small.
            ycell.f = null; //todo how to set the formatting?
            pdfRow.cells.push(ycell);             
        } else {
            //flat view gets each y axis dim put into it's own cell
            for (var i=0; i<yAxisArr.length; i++) {
                var a = yAxisArr[i];
                var ycell = {};
                ycell.d = a.title;
                ycell.t = 0; //0=segment, 1=data.  used this method to keep the JSON small.
                ycell.f = null; //todo how to set the formatting?
                pdfRow.cells.push(ycell);                
            }                         
        }    

        //now add in the x axis titles
        for (var i=0; i<dispXaxisObj.values.length; i++) {
            var xAxisVal = dispXaxisObj.values[i];
            if (!xAxisVal.hidden) {
                var cell = {};
                cell.d = xAxisVal.name;
                cell.t = 1; //0=segment, 1=data.  used this method to keep the JSON small.
                cell.f = null; //todo how to set the formatting?
                pdfRow.cells.push(cell);                
            }
        }        
        pdfRows.push(pdfRow);          
    }
    
    function recurseAndBuildPDFflat(node, dispXaxisObj) {
        var pdfRow = {};
        pdfRow.indent = 0;
        pdfRow.cells = [];
        
        var expanded = false;
        var hasId = false;
        
        if ('depth' in node) {
            pdfRow.indent = node.depth;
        }
        
        var recurseAgain = false;
        if ('children' in node) {
            recurseAgain = true;
        }
        
        if (isFlatRollup) {
            //we we are doing the FlatRollupTB, only recurse if we have children and
            //aren't at the topParent level
            if ('isTopParent' in node) {
                if (node.isTopParent) {
                    recurseAgain = false;    
                }   
            }                  
        }
        
        if (recurseAgain) {
            for (var i=0; i<node.children.length; i++) {
                var n = node.children[i];
                //recursively call this function again
                recurseAndBuildPDFflat(n, dispXaxisObj);      
            }            
        } else {
            var supressNode = false;
            if (isFlatRollup) {
                supressNode = true;
                if ('isTopParent' in node) {
                    if (node.isTopParent) {
                        supressNode = false;
                    }    
                }
                if ('type' in node) {
                    //total nodes which aren't the grand total
                    if ( (node.type == 'Total') && (node.id != 'totalRoot_total') ){
                        supressNode = true;
                    }
                }
                
                if (node.id == 'totalRoot_total') {
                    supressNode = false;
                }
            }                               

            //only want to output the leaf nodes for the flat view
            var reportType = report.type;

            if (node.type != 'Total') { //don't add in the total nodes for the flat PDF export
                //add in all the yDim vals as cells in the row
                for (var i=0; i<node.yDimVals.length; i++) {
                    var yDim = node.yDimVals[i];
                    var ycell = {};
                    ycell.d = yDim.name;
                    ycell.t = 0; //0=segment, 1=data.  used this method to keep the JSON small.
                    ycell.f = null; //todo how to set the formatting?
                    pdfRow.cells.push(ycell);                 
                }
                
                //loop through the dispXaxisObj and add all the remaining cells in for this row.
                for (var i=0; i<dispXaxisObj.values.length; i++) {
                    var xAxisVal = dispXaxisObj.values[i];
                    if (!xAxisVal.hidden) {
                        var dataId = xAxisVal.id + '__RU'; //flat view always uses the rollup amounts
                        var cell = {};
                        cell.d = kendo.toString(node.data[dataId], pdfNumFormat);
                        cell.t = 1; //0=segment, 1=data.  used this method to keep the JSON small.
                        cell.f = null; //todo how to set the formatting?
                        pdfRow.cells.push(cell);
                    }
                }
                if (!supressNode) {
                    pdfRows.push(pdfRow); 
                }
            } else {
                var yAxisArr = getAxisDimension('y', model);
                for (var i=0; i<yAxisArr.length; i++) {
                    var a = yAxisArr[i];
                    var ycell = {};
                    ycell.d = 'Total ' + a.title;
                    ycell.t = 0; //0=segment, 1=data.  used this method to keep the JSON small.
                    ycell.f = null; //todo how to set the formatting?
                    pdfRow.cells.push(ycell);                
                }
                
                if(reportType == StatementType.TB){
                    //loop through the dispXaxisObj and add all the remaining cells in for this row.
                    for (var i=0; i<dispXaxisObj.values.length; i++) {
                        var xAxisVal = dispXaxisObj.values[i];
                        if (!xAxisVal.hidden) {
                            var dataId = xAxisVal.id + '__RU'; //flat view always uses the rollup amounts
                            var cell = {};
                            cell.d = kendo.toString(node.data[dataId], pdfNumFormat);
                            cell.t = 2; //0=segment, 1=data, 2=total/calculated.  used this method to keep the JSON small.
                            cell.f = 3; //todo how to set the formatting?
                            pdfRow.cells.push(cell);
                        }
                    }
                    if (!supressNode) {
                        pdfRows.push(pdfRow); 
                    }
                }
            }
        }
    }

    
    function buildPDFIndented(repForPresentation, dispXaxisObj) {
        
        //get the y axis title for the header row
        //add in the column for the yAxis (could be more than one dim in it)
        var yAxisArr = getAxisDimension('y', model); 
        var yFields = [];
        for (var i=0; i<yAxisArr.length; i++) {
            var a = yAxisArr[i];
            yFields.push(a.objName);
        }           
        var yAxisCompField = yFields.join('_');        

        
        for (var i=0; i<repForPresentation.length; i++) {
            var row = repForPresentation[i];
            var pdfRow = {};
            pdfRow.indent = row.depth-1;
            pdfRow.cells = [];            
            
            //push in the dim col
            var ycell = {};
            ycell.d = row[yAxisCompField];
            ycell.t = 0; //0=segment, 1=data.  used this method to keep the JSON small.
            ycell.f = null; //todo how to set the formatting?   
            pdfRow.cells.push(ycell);
            
            for (var j=0; j<dispXaxisObj.values.length; j++) {
                var xAxisVal = dispXaxisObj.values[j];
                var cellformat = 1;
                
                if (!xAxisVal.hidden) {
                    var dataId = xAxisVal.id;
                    var cell = {};
                    cell.d = kendo.toString(row[dataId], pdfNumFormat);
                    cell.t = 1;                     //0=segment, 1=data.  used this method to keep the JSON small.
                    
                    if (row.reportingAccount && !isFlatRollup && row[dataId] == 0) {
                        //blank out the 0 reporting accounts
                        cell.d = '';
                    }

                    pdfRow.cells.push(cell);
                }
            }            
            pdfRows.push(pdfRow);            
        }
    }
    
    
    
    
    function recurseAndBuildPDFtree(node, dispXaxisObj) {
        var pdfRow = {};
        pdfRow.indent = 0;
        pdfRow.cells = [];
        
        var expanded = false;
        var hasId = false;
        
        //build up the y axis hierarchy columns
        if ('id' in node) {
            hasId = true;
            if (node.id in expandedNodesForPDF) {
                expanded = true;
            }
            
            var arrPath = pdfYaxisPathMap[node.id];
            pdfRow.indent = arrPath.length - 1;
            
            var ycell = {};
            ycell.d = node.name;
            ycell.t = 0; //0=segment, 1=data.  used this method to keep the JSON small.
            if(node.type == 'Total' || node.type == 'Calculated'){
                ycell.t = 3; //3=totaltext&calculated
            }
            ycell.f = null; //todo how to set the formatting?
            pdfRow.cells.push(ycell); 
            
            var expandedGroup = false;
           
            var reportingAccount = false;
            if ('reportingAccount' in node) {
                if (node.reportingAccount) {
                        reportingAccount = true;
                }
            }
            
            if(reportingAccount && expanded){
                expandedGroup = true;
            }

            //loop through the dispXaxisObj and add all the remaining cells in for this row.
            for (var i=0; i<dispXaxisObj.values.length; i++) {
                var xAxisVal = dispXaxisObj.values[i];
                var cellformat = 1;
                if(node.formattype == 'Normal'){
                    cellformat = 1;
                }else if(node.formattype == 'Large'){
                    cellformat = 2;
                }else if(node.formattype == 'Double Line'){
                    cellformat = 3;
                }
                if (!xAxisVal.hidden) {
                    var dataId = xAxisVal.id;
                    if (node.type == 'Total' || !expanded) {
                        dataId += '__RU'; //if it's a totals node, or collapsed node, use the rollup number
                    }
                    
                    var cell = {};
                   
                    //Logic to set cell content value as empty if node is expanded with Group&Data level
                    if(expandedGroup && node.data[dataId] == 0){
                        cell.d = '';
                    }else{
                        cell.d = node.data != undefined ? kendo.toString(node.data[dataId], pdfNumFormat) : 0;
                    }
                    cell.t = 1;                     //0=segment, 1=data.  used this method to keep the JSON small.
                     if(node.type == 'Total' || node.type == 'Calculated'){
                        cell.t = 2;                 //total or calculated section
                        cell.f = cellformat;
                    }
                    
                    if(node.type == 'Total' && node.showFooter == false){
                        cell.t = 5                  //grouping section
                        cell.f = cellformat;
                    }
                    
                    pdfRow.cells.push(cell);
                }
            }
            pdfRows.push(pdfRow);            
        }
        
        //we need to get children if this node is expanded, or doesn't have an Id (root node)
        var getChildren = false;
        if (!hasId || expanded) {
            getChildren = true;
        }
        
        if (('children' in node) && getChildren) {
            for (var i=0; i<node.children.length; i++) {
                var n = node.children[i];
                //recursively call this function again
                recurseAndBuildPDFtree(n, dispXaxisObj);
            }
        }
    }
    
    
    //=========================================================
    // END PDF Export
    //=========================================================            
    
    
    
    
    


    //=========================================================
    // BEGIN API to query the completed OLAP cube
    //=========================================================

  
    function createDisplayAxis() {
        //we need to make an dispXaxisObj from our xAxisObj

        //1) for each x dim value, we need to display each metric.  for example "Jan" becomes "Jan DR" "Jan CR" "Jan Bal"
        //2) filter out any of the x axis elements we don't wan't to display.  For example if we are filtered to a limited number of periods. 
        //   since we still need the data to calculate balances to the beg of time, we will just flag them as hidden rather than remove them.
        //3) add in any special columns which weren't stricly part of the dim values or metrics in the data model.  EX: beg bal, total, etc.
        //   this is the special sauce that converts a plain old BI model into a financial statement or other custom report.
        
        dispXaxisObj = {};
        dispXaxisObj.dim = xAxisObj.dim;
        dispXaxisObj.values = [];
        
        dispXaxisObjDimToMetMap = {};

        console.log('createDisplayAxis xAxisObj 1');
        console.log(JSON.parse(JSON.stringify(xAxisObj)));
        
        if (xAxisObj.dim == null) {
            xAxisObj.dim = null;
            xAxisObj.values = [{'id': 'noDim', 'name': ''}];
        }
        
        console.log('createDisplayAxis xAxisObj 2');
        console.log(JSON.parse(JSON.stringify(xAxisObj)));        

        console.log('createDisplayAxis timeDisplaySettings');
        console.log(timeDisplaySettings);  
        
        //convert the display period,quarter,year booleans into level 3,2,1
        var timeDisplayLevels = [];
        if (timeDisplaySettings.xAxisShowPeriod) {
            timeDisplayLevels.push(3);
        }
        if (timeDisplaySettings.xAxisShowQuarter) {
            timeDisplayLevels.push(2);
        }     
        if (timeDisplaySettings.xAxisShowYear) {
            timeDisplayLevels.push(1);
        }             

        var lowestLevelShown = 3;
        if (timeDisplayLevels.length > 0) {
            lowestLevelShown = timeDisplayLevels[0];
        }

        
        //Step #1
        //iterate over all the values in our xAxis
        for (var i=0; i<xAxisObj.values.length; i++) {
            var xDim = xAxisObj.values[i];

            //default alternating shading is just even / odd
            var alt = (((i % 2) == 0) ? 0 : 1);
            
            //if it is the period axis, we are going to do a 3 level shading scheme
            if (dispXaxisObj.dim == 'Period__c') {
                switch(xDim.level) {
                    case 2:
                        alt = 1;
                        break;
                    case 1:
                        alt = 2;
                        break;
                    default:
                        alt = 0;
                }                
            }            
            
            var hidden = false;
            if (dispXaxisObj.dim == 'Period__c') {
                hidden = ((timeDisplayLevels.indexOf(xDim.level) != -1) ? false : true); //if it isn't to be displayed, hide it
            }
                
            //set whether or not it's the start of a fiscal year
            var FYstart = false;
            if ('FYstart' in xDim) {
                FYstart = xDim.FYstart;
            }
            
            //iterate over our metrics
            for (var m=0; m<model.metrics.length; m++) {
                var met = model.metrics[m];
                var inOLAP = (met.metType == 'Data' ? true : false);
                var dimMetId = (met.metType == 'Data' ? xDim.id + '_' + met.alias + '_' + met.field : xDim.id + '_' + met.field);
                var dimMet = {};
                dimMet.id = dimMetId;
                dimMet.dim = xDim.id;
                dimMet.dimTitle = xDim.name;
                dimMet.periodType = xDim.periodType;
                if (met.alias != null) {
                    dimMet.alias = met.alias;
                }
                dimMet.met = (met.alias == null ? met.field : met.alias + '_' + met.field);
                dimMet.metTitle = met.title;
                dimMet.name = xDim.name + ' ' + met.title; //TODO: write function to name this based on report type
                dimMet.mode = met.mode; //cum, cumYear, nonCum
                dimMet.level = xDim.level;
                dimMet.inOLAP = inOLAP;
                dimMet.hidden = hidden;
                dimMet.alt = alt;
                dimMet.FYstart = FYstart;
                dimMet.metType = met.metType;
                dimMet.format = met.format;
                if (met.formula != null) {
                    dimMet.formula = met.formula;
                }                
                dispXaxisObj.values.push(dimMet);
                
                if (!(dimMet.dim in dispXaxisObjDimToMetMap)) {
                    dispXaxisObjDimToMetMap[dimMet.dim] = {};
                }
                dispXaxisObjDimToMetMap[dimMet.dim][dimMet.met] = dimMet.id;
            }            
        }            
        
        //Step #2
        //iterate over dispXaxisObj and flag anything as hidden which is filtered out.
        //when we filter to a period for instance we may need the previous periods to be in place 
        console.log('createDisplayAxis filtersAppliedPathMap');
        console.log(filtersAppliedPathMap);
        var leafNodesToShow = {};
        var xAxisFiltered = false;
        
        if (dispXaxisObj.dim in filtersAppliedPathMap) {
            var xAxisFilters = filtersAppliedPathMap[dispXaxisObj.dim];
            
            //iterate over the individual filters, ex if we filtered to JAN FEB MAR
            for (var i=0; i<xAxisFilters.length; i++) {
                xAxisFiltered = true;
                var xAxisFilter = xAxisFilters[i];
                
                //loop over the filter hierarchy, ex: JAN, Q1, 2016
                for (var j=0; j<xAxisFilter.length; j++) {
                    leafNodesToShow[xAxisFilter[j]] = true;
                }
                
            }                
        }
        
        //only apply the filters if SOMETHING was filtered.  When there are no filters, we want to show everything.
        if (xAxisFiltered) {
            for (var i=0; i<dispXaxisObj.values.length; i++) {
                var dimMet = dispXaxisObj.values[i];
                //anything that is already hidden, we don't want to show.  We only want to hide additional ones
                //this will maintain the proper period / quarter / year display as specified
                if (!dimMet.hidden) { //if it's being displayed
                    if (!(dimMet.dim in leafNodesToShow)) { //if it's not supposed to be displayed
                        dimMet.hidden = true;
                    }
                }

            }               
        }
        
        //Step #3
        //Add in any "special" columns which don't come from the OLAP cube directly
        if (report.type == StatementType.TB) {        
            var begBalHidden = (timeDisplayLevels.length==0 ? true : false); //don't show if no periods are shown
            
            //if it is a non-period dim, always show beg bal
            if (dispXaxisObj.dim != 'Period__c') {
                begBalHidden = false;
            }
            
            var dimMet = {};
            dimMet.id = 'begBal';
            dimMet.dim = null;
            dimMet.name = 'Beg Bal';
            dimMet.mode = 'custom';
            dimMet.level = lowestLevelShown;
            dimMet.inOLAP = false;
            dimMet.hidden = begBalHidden;
            dimMet.alt = 0; 
            dispXaxisObj.values.unshift(dimMet); //add beg to the beginning
        }
        
        if (report.type == StatementType.MCTB) {        
            var begBalTrans = {};
            begBalTrans.id = 'begBalTrans';
            begBalTrans.dim = 'noDim';
            begBalTrans.dimTitle = '';
            begBalTrans.name = 'Beg Bal';
            begBalTrans.metTitle = 'Beg Bal';
            begBalTrans.mode = 'custom';
            begBalTrans.level = lowestLevelShown;
            begBalTrans.inOLAP = false;
            begBalTrans.hidden = false;
            begBalTrans.alt = 0;

            //add beg bal trans to the beginning
            dispXaxisObj.values.unshift(begBalTrans); 
            
            //clone the trans object into the func and override the id
            var begBalFunct = JSON.parse(JSON.stringify(begBalTrans));
            begBalFunct.id = 'begBalFunc';
            begBalFunct.dim = 'noDim';
            begBalFunct.dimTitle = '';
            
            //loop through and find the index location of a_trans_bal.
            //we want to insert a beg bag functional after this
            var transBalLoc;
            for (var i=0; i<dispXaxisObj.values.length; i++) {
                var dx = dispXaxisObj.values[i];
                if (dx.met == 'a_trans_bal') {
                    transBalLoc = i;
                    break;
                }
            }                 
            transBalLoc ++;
            //splice begBalFunct into dispXaxisObj at the right location
            dispXaxisObj.values.splice(transBalLoc, 0, begBalFunct);
        }        
        
        
        
        if (report.type == StatementType.IS) {        
            var dimMet = {};
            dimMet.id = 'total';
            dimMet.dim = null;
            dimMet.name = 'Total';
            dimMet.mode = 'custom';
            dimMet.level = 3; //assuming month period, may need to make this dynamic for quarter views
            dimMet.inOLAP = false;
            dimMet.hidden = hideTotal; //KNDy - 14819
            dimMet.alt = 0;  //TODO change to a loop through all the non-hidden fields
            dispXaxisObj.values.push(dimMet); //add total to the end
        }        
        
        console.log('dispXaxisObj');
        console.log(dispXaxisObj);
    }        
    
    
    
    var hierSort = function (a, b) {
        var aSort='', bSort='';

        if ('sort' in a) {
            aSort = a.sort;
        } else if ('order' in a) {
            aSort = a.order;
        } else if ('name' in a) {
            aSort = a.name;
        }
        
        if ('sort' in b) {
            bSort = b.sort;
        } else if ('order' in b) {
            bSort = b.order;            
        } else if ('name' in a) {
            bSort = b.name;
        }        
        
        
        var aIsTotal = false;
        var bIsTotal = false;   
        if ('type' in a) {
                aIsTotal = (a.type == 'Total');
        }
        if ('type' in b) {
                bIsTotal = (b.type == 'Total');
        }        
        
        //see if it is 2 total nodes.  we sort like any other node in this case.
        if (aIsTotal && bIsTotal) {
            //if they are numbers, do numeric sort
            if ((!isNaN(aSort)) && (!isNaN(bSort))) {
                return a - b;
            } else {
                //1 or both are alphanumeric.  convert to alpha and sort
                aSort += '';
                bSort += '';
                return aSort == bSort ? 0 : aSort > bSort ? 1 : -1;  
            }            
        }

        //if it is a total node against a non-total node, total nodes always go last        
        if (aIsTotal) {
                return 1;
        }
        if (bIsTotal) {
                return -1;
        }        
        
        //if they are numbers, do numeric sort
        if ((!isNaN(aSort)) && (!isNaN(bSort))) {
            return aSort - bSort;
        } else {
            //1 or both are alphanumeric.  convert to alpha and sort
            aSort += '';
            bSort += '';
            return aSort == bSort ? 0 : aSort > bSort ? 1 : -1;  
        }
    };     
    function recurseAndSortHierarchy(node) {
        if ('children' in node) {
            
            //do a custom sort on the children
            node.children.sort(hierSort);
            
            for (var i=0; i<node.children.length; i++) {
                var n = node.children[i];
                recurseAndSortHierarchy(n);
            }
        }
    }  
    
         
    
    function assembleData() {

        //the multi-currency trial balance is going to have to query the beg bal separately from the current period selected bal
        //from the from period we need to build a filter of all the prior periods to be able to query for the beg bal
        if (report.type == StatementType.MCTB) {
            //get the period from
            var periodFrom;
            if ('Period__c' in filtersAppliedPathMap) {
                if (filtersAppliedPathMap.Period__c.length > 0) {
                    var periodFromFilter = filtersAppliedPathMap.Period__c[0];
                    periodFrom = periodFromFilter[periodFromFilter.length-1];
                }
            }
            begBalFilter = getBegBalPeriods(periodFrom, segmentFlat.Period__c);
            //convert the individual period to an array of it's parents down to it.  EX: year->quarter->month
            for (var i=0; i<begBalFilter.length; i++) {
                begBalFilter[i] = segmentNodePathMap.Period__c[begBalFilter[i]];
            }
            
            console.log('begBalFilter');
            console.log(begBalFilter);
        }                
        
        //clone off a copy of the report structure
        //we'll use this to hang all the data off of
        asmRep =  JSON.parse(JSON.stringify(report.sectionsHier));  

        //now walk the hierarchy and sort it
        recurseAndSortHierarchy(asmRep);
        
        
        //clear the presentationdata flat array
        presentationData = [];

        createDisplayAxis();
        
        
        //recurse down to all the leaf nodes and decorate the data sections with the data from the cube.
        //the report structure is providing our "section" dimension.  an intermediary layer for inserting 
        //levels and calculation nodes into the hierarchy (typically gl accounts)

        //we are going to pass in the x structure which is a 2D array that is a flattened hierarchy of period->quarter->year

        console.log('assembleData asmRep'); 
        console.log(JSON.parse(JSON.stringify(asmRep)));     
        
        asmRep = recurseChildrenAddData(asmRep);

        console.log('asmRep 2');  
        console.log(JSON.parse(JSON.stringify(asmRep)));             

        asmRep = recurseChildrenAddOverride(asmRep);
        asmRep = doCalculations(asmRep);
        
        //for Multi Currency Trial Balance we want to remove the trans / funct nodes if there are no values across the X axis for them (all null / 0);
        //it doesn't makes sense to show trans / funct currency combinations like EUR / USD if there are no values for them for the period.
        if (report.type == StatementType.MCTB) {
            asmRep = collapseMultiCurrency(asmRep);
        }
        
        console.log('asmRep 3');
        // recurse logic to add cell format(while saving pdf) for some nodes if not provided
        recurseAndBuildFormat(asmRep);
        console.log(JSON.parse(JSON.stringify(asmRep)));            
        
        
        //figure out what format of the report we should be returning
        //kendo treelist actually takes in a flat format and makes the hierarchy itself
        var yAxisObj = getAxisDimension('y', model);
        
        if (format == 'flat') {
            recurseAndBuildFlatPresentationData(asmRep);
            repForPresentation = presentationData;      
        } else {
            //return the report in the default, hierarchical format
            repForPresentation = asmRep;
        }
        var assembled = {};
        assembled.asmRep = repForPresentation;
        assembled.yAxis = yAxisObj;
        assembled.xAxis = dispXaxisObj;
        assembled.drilldownURL = '{!drilldownURL}';
        assembled.pdfURL = '{!pdfURL}';        
        assembled.csvURL = '{!csvURL}';              
        
        //create a map of all the segment nodes.  this will be for the drilldown report
        //it will allow us to build parent / child relationships
        //for the yAxis it will have the grouping section nodes as well (groups aren't in the OLAP or hierarchy object)
        segmentNodes = {}; //init the map
        
        buildFlatSegmentNodes();
        assembled.segmentNodes = segmentNodes;
        
        window.parent.postMessage({"type": "assembled", "assembled": assembled}, "*");  
    }
    
    function collapseMultiCurrency(asmRep) {
        //clone the object, and remove the children
        var asmRepFiltered = JSON.parse(JSON.stringify(asmRep));
        delete asmRepFiltered.children;
        asmRepFiltered.children = [];
        
        //recreate a filtered version of the children
        for (var i=0; i<asmRep.children.length; i++) {
                var GLnode = asmRep.children[i];
            
            //push in a clone of the GL node with no children (trans currency nodes)
            var GLnodeClone = JSON.parse(JSON.stringify(GLnode));
                        delete GLnodeClone.children;  
            GLnodeClone.children = [];
            asmRepFiltered.children.push(GLnodeClone);

            for (var t=0; t<GLnode.children.length; t++) {
                var transCurrNode = GLnode.children[t]; 
                var isLast = (t == GLnode.children.length - 1);
                var hasVals = false;                

                //loop through the dispXaxisObj, see if there are any data values in this node
                for (var j=0; j<dispXaxisObj.values.length; j++) {
                    var xAxisVal = dispXaxisObj.values[j];
                    if (!xAxisVal.hidden) {
                        var dataId = xAxisVal.id;
                        var cell = transCurrNode.data[dataId];
                        if (cell != null && cell != 0) {
                            hasVals = true;
                            break;
                        }    
                    }
                }
                
                var currId = transCurrNode.yDimVals[0].id;
                var nextId;
                if (!isLast) {
                    nextId = GLnode.children[t+1].yDimVals[0].id;
                }
                
                //gl may be repeated over and over if there are many trans/funct currency combinations
                //this variable tells us if we are at the last GL in a group of gls, in other words if the next GL is a is a different one
                var lastGLinGroup = (currId != nextId);
                
                if (hasVals) {
                    asmRepFiltered.children[i].children.push(transCurrNode);
                }                
            }

            if (asmRepFiltered.children[i].children.length == 1) { //length == 1 is really like 0.  1 is the totals node
                //if we didn't add a node for trans currency, let's add one now.
                //it will be a blank row with no trans/funct specified because this means we never found any values      
                var blankNode = JSON.parse(JSON.stringify(GLnode.children[0])); //clone the first trans curr value
                blankNode.id = GLnode.id + '_' + 'blank';
                blankNode.hId = blankNode.id;
                blankNode.name = '';
                blankNode.origId = '';
                
                blankNode.filter.KNDY4__Currency__c = '';
                blankNode.yDimVals[1].id = '';
                blankNode.yDimVals[1].name = '';
                
                blankNode.data.KNDY4__Currency__c = null;
                
                asmRepFiltered.children[i].children.push(blankNode);                
            }
        }
        
        return asmRepFiltered;
    }
    
    
    

    function recurseAndPopulateTotalNodes(asmRep, node, parentNode) {    
        recurseAndPopulateTotalNodesWorker(asmRep, node, parentNode);
        return node;
    }
    function recurseAndPopulateTotalNodesWorker(asmRep, node, parentNode) {
        //console.log(JSON.parse(JSON.stringify(node.data)));
        
        if (parentNode != null) {
            if (node.type == 'Total') {
                
                var isMultiDimTotal = false;
                if (node.yDimVals.length > 1) {
                        isMultiDimTotal = true;
                }
                
                if (isMultiDimTotal) {
                    //if it is a multi dim total, it means we have to spider back up through the hierarchy to
                    //find all the values we need to populate this.
                    
                    //init the data to 0's
                    node.data = {};
                    for (var i=0; i<dispXaxisObj.values.length; i++) {
                        var x = dispXaxisObj.values[i];
                        node.data[x.id] = 0;
                        node.data[x.id+'__RU'] = 0;
                    }                        
                    
                    recurseAndPopulateMultiDimTotals(asmRep, node.data, node.yDimVals);
                    
                } else {
                    //just a single dim total node.  simple to populate.                    
                    //clone the rolled up data from the parent into the total node
                    node.data = {};
                    for (var i=0; i<dispXaxisObj.values.length; i++) {
                        var x = dispXaxisObj.values[i];
                        node.data[x.id] = parentNode.data[x.id+'__RU'];
                        node.data[x.id+'__RU'] = parentNode.data[x.id+'__RU'];
                    }                    
                }
            }
        }
        
        if ('children' in node) {
            for (var i=0; i<node.children.length; i++) {
                var n = node.children[i];
                recurseAndPopulateTotalNodesWorker(asmRep, n, node);
            }
        }
    }
    
    
    function recurseAndPopulateMultiDimTotals(asmRep, nData, yDimVals) {
        
        //the id we are going to look for is the composite id of the yDimVals, excluding the one we are at, because we want to move up a level
        var yDimValsParent = JSON.parse(JSON.stringify(yDimVals));
        var yDimValLeaf;
        if (yDimValsParent.length > 1) {
                        yDimValLeaf = yDimValsParent[yDimValsParent.length-1].id;
            yDimValsParent.pop();
        } else {
                return;
        }
        
        var arrIds = [];
        for (var i=0; i<yDimValsParent.length; i++) {
                arrIds.push(yDimValsParent[i].id);
        }
        
        var compParentId = arrIds.join('_');
        var yDimValNode = recurseAndFindYdimValNode(asmRep, compParentId);
        //console.log('recurseAndPopulateMultiDimTotals yDimValNode yDimValLeaf');
        //console.log(yDimValNode);
        //console.log(yDimValLeaf);
        
        if (yDimValNode !== false) {
            //recurse through all the children of this parent yDim, recurse to all the leaf nodes where the yDimVal matches
            //add these into the data object
            recurseParentGetLeafData(yDimValNode, nData, yDimValLeaf);
        }
    }

        function recurseParentGetLeafData(node, nData, yDimValLeaf) {
        //see if this node of the parent's children matches the yDimValLeaf
        var yDimValParentLeaf = node.yDimVals[node.yDimVals.length-1].id;
        
        if ( (yDimValParentLeaf == yDimValLeaf) && (node.type != 'Total') ){
            for (var i=0; i<dispXaxisObj.values.length; i++) {
                var x = dispXaxisObj.values[i];
                nData[x.id] += node.data[x.id];
                nData[x.id+'__RU'] += node.data[x.id+'__RU'];
            }
            //matches, no need to recurse deeper
            return;
        }
        
        if ('children' in node) {
            for (var i=0; i<node.children.length; i++) {
                var n = node.children[i];
                recurseParentGetLeafData(n, nData, yDimValLeaf);
            }
        }
    }
    
    function recurseAndFindYdimValNode(node, searchId) {
                if (node.id == searchId) {
                return node;
        }
        if ('children' in node) {
            for (var i=0; i<node.children.length; i++) {
                var n = node.children[i];
                var found = recurseAndFindYdimValNode(n, searchId);
                if (found) {
                        return found;
                }
            }
        }  
        return false;
    }
    
    
    
    
    function buildFlatSegmentNodes() {
        //first recurse asmRep to get not only the hierarchy from the report structure
        //as well as whatever was in the OLAP cube
        for (i=0; i<model.dimensions.length; i++) {
            var field = model.dimensions[i].objName;
            segmentNodes[field] = {}; //init the node object for this dim
            recurseAndBuildFlatNodes(segmentHierarchy[field], field, null);
        }
    }
    
    function recurseAndBuildFlatNodes(node, dim, parentNode) {
        var pId = null;
        if (parentNode != null) {
            pId = parentNode.id;
        }
        
        if (node != undefined && node.id != null) {
            segmentNodes[dim][node.id] = {'id': node.id, 'parentId': pId, 'name': node.name};
        }
        if (node != undefined && 'children' in node) {
            for (var i=0; i<node.children.length; i++) {
                var n = node.children[i];
                recurseAndBuildFlatNodes(n, dim, node);
            }
        }
    }    
    
    
    function recurseChildrenAddOverride(node) {    
        recurseChildrenAddOverrideWorker(node,null);
        return node;
    }    
    function recurseChildrenAddOverrideWorker(node,parent) {
        
        if(!('metric' in node))
                node.metric = {};
        
        if(parent != null){
            for(key in parent.metric){
                if(key != 'title')
                    node.metric[key] = parent.metric[key];
            }
        }
        
        // setting custom title and formula
        if('title' in node.metric)
                node.name = node.metric.title;
       
        
        if ('children' in node) {
            for (var i=0; i<node.children.length; i++) {
                var n = node.children[i];
                //recursively call this function again
                recurseChildrenAddOverrideWorker(n,node);
            }
        }
        
    }
    
    function recurseChildrenAddData(node) {    
        recurseChildrenAddDataWorker(node);
        return node;
    }    
    function recurseChildrenAddDataWorker(node) {
        if ('children' in node) {
            for (var i=0; i<node.children.length; i++) {
                var n = node.children[i];
                if (!('type' in n)) {
                    n.type = 'Data'; //data will be default if no type
                }
                
                if (n.type == 'Data') {
                    //the name of the data section will match up to the top of the gl hierarchy dimension in the olap cube
                    //this will give us our section level totals for the top of the grid.  it won't have GL account level detail
                    n.data = getSlab(n.filter);
                    if (n.data != null) {
                        n.dataRolledUp = true;
                    }                            
                    
                    //now recurse from this section down to the top parent GL and all of its sub gls and add them them into the
                    //report structure as child->grandchild, etc nodes with data amounts from the OLAP cube at each level
                    addDescendantsAndSlabs(n);
                    continue; //no need to recurse any deeper 
                }
                //recursively call this function again
                recurseChildrenAddDataWorker(n);
            }
        } else {
                    
            //=== begin added Dan 4/20/16
            if (!('type' in node)) {
                node.type = 'Data'; //data will be default if no type
            }  
            
            if (node.type == 'Data') {
                //the name of the data section will match up to the top of the gl hierarchy dimension in the olap cube
                //this will give us our section level totals for the top of the grid.  it won't have GL account level detail
                node.data = getSlab(node.filter);
                if (node.data != null) {
                    node.dataRolledUp = true;
                }                
            }            
            //=== end added Dan 4/20/16
        }
        //return node;
    }
    
    
    function addDescendantsAndSlabs(node) {
        if ('children' in node) {
            for (var i=0; i<node.children.length; i++) {
                var n = node.children[i];

                if (!('type' in n)) {
                    n.type = 'Data'; //data will be default if no type
                }
                
                n.data = getSlab(n.filter);
                if (n.data != null) {
                    n.dataRolledUp = true;
                }   
    
                //recursively call this function again
                addDescendantsAndSlabs(n);
            }
        } else {
            node.data = getSlab(node.filter);
            if (node.data != null) {
                node.dataRolledUp = true;
            }   
            
        }    
    }

        function getSlab(nodeFilter) {    
        //console.log('getSlab nodeFilter');
        //console.log(nodeFilter);       

        var nyFilters = [];
        
        for (var f in nodeFilter) {
            if (nodeFilter.hasOwnProperty(f)) {
                var segmentName = f;
                var segmentVal = nodeFilter[f];
                
                //find out if dim is a hierarchy or not
                var isHier = dimToIsHierMap[segmentName];                
                
                if (isHier) {
                    if (segmentVal in segmentNodePathMap[segmentName]) {
                        var yfilterTemp = {};
                        yfilterTemp.dim = segmentName;
                        yfilterTemp.filter = segmentNodePathMap[segmentName][segmentVal];
                        nyFilters.push([yfilterTemp]);
                    } else {
                        console.log('*** getSlab NULL dimension: ' + segmentName + ', ' + segmentVal);
                        //console.log(segmentNodePathMap);
                        return;
                    }                     
                } else {
                    //if dim isn't hierarchy, no need to do the path map to query the cube
                                        var yfilterTemp = {};
                    yfilterTemp.dim = segmentName;
                    yfilterTemp.filter = segmentVal;
                    nyFilters.push([yfilterTemp]);
                }
            }
        }
        
        
        //console.log('OLAPfilter 1');
        //console.log(OLAPfilter);
        
        //add in the column for the yAxis (could be more than one dim in it)
        var yFields = [];
        var yFilterVals = [];
        for (var i=0; i<model.yAxis.length; i++) {
            var a = model.yAxis[i];
            yFields.push(a);
                        
            var filterVal;
            if (a in nodeFilter) {
                filterVal = nodeFilter[a];
            }
            
            yFilterVals.push(filterVal);
        }
        var yAxisCompField = yFields.join('_');
        var yAxisCompVal = safeName(yFilterVals.join('_'));        

        var row = {};
        row[yAxisCompField] = yAxisCompVal;

        //the cube will will let us filter on many dimensions at once, but only one value per dimension
        //we may have many values on the period dimension, since we allow for dimension ranges
        //the Y axis will only have one value since we are getting a slab
        //the X axis we are going to iterate over
        //we need to check any remaining N dimensions.  ones which have only one value we are going to lump
        //in with the Y axis filter.  if they have more than 1 value we need to iterate over all the combinations
        //of the multi valued dimension filters with a nested loop

        //var hasMultiValNdimFilters = false;
        //var multiValNdimFilters = {};
        
        for (var nDim in filtersAppliedPathMap) {
            if (filtersAppliedPathMap.hasOwnProperty(nDim)) {   
                
                if (model.yAxis.length == 1) {
                    //Single dim on the Y Axis.  if this is an X dim or Y dim skip it
                if ((nDim == dispXaxisObj.dim) || (model.yAxis.indexOf(nDim) != -1) ) {
                    continue;
                }
                } else {
                    //multi dims on the y axis.  can't skip on the Y, only x
                    if (nDim == dispXaxisObj.dim) {
                        continue;
                    }                   
                }   
                
                //see if the nDim is already in the nyFilters.  if it is, the nyFilters is going to take precedence.
                //this is because we need to show what is supposed to be in the Y filter node.
                var yDimInNdim = false;
                for (var i=0; i<nyFilters.length; i++) {
                    var nyFilter = nyFilters[i];
                    for (var j=0; j<nyFilter.length; j++) {
                    var yDim = nyFilter[j].dim;
                        if (yDim == nDim) {
                            yDimInNdim = true;
                            //debugger;
                            break;
                        }                    
                    }
                    if (yDimInNdim) {
                        break;
                    }
                }
                if (yDimInNdim) {
                    continue;
                }
                
                var temparray = [];
                for(var loop=0;loop < filtersAppliedPathMap[nDim].length;loop++){
                    var nfilterTemp = {};
                    nfilterTemp.dim = nDim;
                    nfilterTemp.filter = filtersAppliedPathMap[nDim][loop];
                    temparray.push(nfilterTemp);
                }
                nyFilters.push(temparray);
            }
        }

        
        var nyFiltersBegBal = JSON.parse(JSON.stringify(nyFilters));
        var filtersAppliedPathMapBegBal = JSON.parse(JSON.stringify(filtersAppliedPathMap));
        
        //delete the period filters from OLAPfilterBegBal, since we know they will be wrong.
        //beg bal is a different period filter.
       
        for(var x=0; x < nyFiltersBegBal.length; x++){
            if(nyFiltersBegBal[x].dim == 'Period__c'){
                nyFiltersBegBal.splice(x,1);
            }    
        }
        
        //overwrite the period filters with the the beg bal period filters
        filtersAppliedPathMapBegBal.Period__c = begBalFilter;

        if (report.type == StatementType.MCTB) {
            
            for (var nDim in filtersAppliedPathMapBegBal) {
                if (filtersAppliedPathMapBegBal.hasOwnProperty(nDim)) {   
                    
                    //var dimFilters = filtersAppliedPathMapBegBal[nDim];

                    //if this is an X or Y dim skip it
                    if ((nDim == dispXaxisObj.dim) || (model.yAxis.indexOf(nDim) != -1)) {
                        continue;
                    }            
                    
                    var nfilterTemp = {};
                    nfilterTemp.dim = nDim;
                    nfilterTemp.filter = filtersAppliedPathMapBegBal[nDim];
                    nyFiltersBegBal.push(nfilterTemp);
                }
            }
        }                
        
        

        //find out if xAxis is a hierarchy or not
        var xIsHier = dimToIsHierMap[dispXaxisObj.dim];
        
        //performing cartesian
        var nyfiltersProduct = cartesianProduct(nyFilters);
        var nyfiltersProductBegBal = cartesianProduct(nyFiltersBegBal);
        
        for (var i=0; i<dispXaxisObj.values.length; i++) {
            var x = dispXaxisObj.values[i];
            
            //see if it is the MultiCurrency TB beg bal metrics
            var isMCbegBal = (x.id == 'begBalTrans' || x.id == 'begBalFunc'); 
            
            if (!x.inOLAP && !isMCbegBal) {
                //some of the special dispXaxisObj aren't in OLAP, just initialize them to 0
                row[x.id] = 0;
                continue; 
            }

            var xDimVal = x.dim;
            if (xIsHier) {
                //from the Id of this xAxis value, we need to get an array of this plus all of its ancestors
                //to do a valid request of the hierarchical OLAP cube at that level of the hierarchy            
                if (x.dim in segmentNodePathMap[dispXaxisObj.dim]) {
                    xDimVal = segmentNodePathMap[dispXaxisObj.dim][x.dim];
                } else {
                    console.log('*** ERROR: ' + dispXaxisObj.dim + ' dim val ' + x.id + ' is not the the ancestor map.');
                }    
            }    

            //query the slab with the appropriate filters for begBal or not.  The begBal is currently just for the Multi Currency Trial balance.
            if (isMCbegBal) {
                
                //we have to clone and override the metric for the beg bal since it is really the end bal of prior periods
                var xBegBal = JSON.parse(JSON.stringify(x));

                if (x.id == 'begBalTrans') {
                    x.met = 'a_trans_bal';
                } else if (x.id == 'begBalFunc') {
                    x.met = 'a_funct_bal';
                }
                
                getSlabWorker(row, nyfiltersProductBegBal, xDimVal, x, filtersAppliedPathMapBegBal);
            } else {
                getSlabWorker(row, nyfiltersProduct, xDimVal, x, filtersAppliedPathMap);    
            }
            
        }
        
        return row;
    }      


    function getSlabWorker(row, nyfiltersProduct, xDimVal, x, filtersAppliedPathMap) {
        
        /*
        console.log('getSlabWorker nyfiltersProduct, xDimVal, x');
        console.log(nyfiltersProduct);
        console.log(xDimVal);
        console.log(x);
        */
        
        var metVal = 0;
        
        //if we have one, add the x axis value we are on to the OLAP filter
        var OLAPfilter = {};
        if (dispXaxisObj.dim != null) {
                OLAPfilter[dispXaxisObj.dim] = xDimVal;
        }    

        for (var i=0; i < nyfiltersProduct.length; i++) {
            
            for(var j=0; j < nyfiltersProduct[i].length; j++){
                //add in the additional nDim filter
                OLAPfilter[nyfiltersProduct[i][j].dim] = nyfiltersProduct[i][j].filter;    
            }
            
            metVal += getCellForSlab(OLAPfilter, x.met);
        }

        row[x.id] = metVal;           
    }      
        function cartesianProduct(argsdata) {
        if (!argsdata || argsdata.length < 1)
            return [];
        else {
            var head = argsdata[0];
            var tail = argsdata.slice(1);
            var result = [];
            for (var i = 0; i < head.length; i++) {
                var tailPortion = cartesianProduct(tail);
                if (tailPortion && tailPortion.length > 0) {
                    for (var j = 0; j < tailPortion.length; j++) {
                        result.push([head[i]].concat(tailPortion[j]));
                    }
                }
                else
                    result.push([head[i]]);
            }
            return result;
        }
    }      
            
    
    function getCellForSlab(filter, met) {
        //console.log('getCellForSlab filter met');
        //console.log(filter);
        //console.log(met);

        var metVal = 0;
        var cell = cube.getCell(filter);
        
        if (cell != null) {
            if (met in cell) {
                if (cell[met] != null) {
                    metVal = cell[met];
                }
            } else {
                console.log('*** ERROR: ' + met + ' not in cell');
            }
        }       
        return metVal;
    }    
    
    //this function recurses down all the report nodes and calculates the calculated sections
    //as well as the grouping section reporting totals
    function doCalculations(asmRep) {

        asmRep = initializeData(asmRep, dispXaxisObj);
        
        asmRep = recurseChildrenDoCalcNetIncome(asmRep, dispXaxisObj, asmRep);
        
        //do a temp rollup clone to pass to the calc sections without doing it to the main report yet
        var asmRepTemp = $.extend(true, {}, asmRep);
        
        
        console.log('asmRep 3.25');
        console.log(JSON.parse(JSON.stringify(asmRepTemp)));            
        
        asmRepTemp = calcRollups(asmRepTemp);
        asmRepTemp = recurseAndPopulateTotalNodes(asmRepTemp, asmRepTemp, null);             
        
        console.log('asmRep 3.5');
        console.log(JSON.parse(JSON.stringify(asmRepTemp)));        
        
        //asmRep = recurseChildrenDoCalcYaxis(asmRep, dispXaxisObj, asmRepTemp);

        asmRep = recurseChildrenDoCumXaxis(asmRep, dispXaxisObj);
        asmRep = calcRollups(asmRep);
        
        console.log('asmRep 4');
        console.log(JSON.parse(JSON.stringify(asmRep)));
        
        //everything above this is working on the data ids only
        //below this is working on the data ids and the __RU rollup ids too
        asmRep = breakOutRollups(asmRep);
        
        console.log('asmRep 5');
        console.log(JSON.parse(JSON.stringify(asmRep)));        
        
        asmRep = recurseAndPopulateTotalNodes(asmRep, asmRep, null);     
        
        console.log('asmRep 6');
        console.log(JSON.parse(JSON.stringify(asmRep)));              

        //do the calculations again to pick up any multi dim y axis calculations which were dependent on the multi
        //dim total nodes
        asmRep = recurseChildrenDoCalcYaxis(asmRep, dispXaxisObj, asmRep);        

        asmRep = recurseChildrenDoCalcXaxis(asmRep, dispXaxisObj);       
        
        
        //if there are any percentage calc metrics, we need to do calc these separate again
        //this is because we couldn't back into the numbers like we could with regular number amounts
        //we can't add or subtract the percentages and get the right numbers
        asmRep = recurseChildrenDoPercentCalcXaxis(asmRep, dispXaxisObj); 
        
        if (hide0Bal) {
            asmRep = recurseChildrenCheck0Balance(asmRep, dispXaxisObj);         
        }    
    
        return asmRep;
    }

    
    function initializeData(node, dispXaxisObj) {
        initializeDataWorker(node, dispXaxisObj);
        return node;
    }
    function initializeDataWorker(node, dispXaxisObj) {
        //console.log('initializeDataWorker: ' + node.name);
        if(!('data' in node)){
            node.data = {};
        } else {
            if(node.data == null){
                node.data = {};
            }        
        }    

        for (var i=0; i<dispXaxisObj.values.length; i++) {
            var x = dispXaxisObj.values[i];
            if(!(x.id in node.data)){
                node.data[x.id] = 0;
            }
        }
        if ('children' in node) {
            for (var i=0; i<node.children.length; i++) {
                var n = node.children[i];
                //recursively call this function again
                initializeDataWorker(n, dispXaxisObj);
            }
        }
    } 
        
    function calcRollups(nested) {
        calcRollupsReverse(nested, null);
        return nested;
    }
    
    function calcRollupsReverse(node, parent) {
        if ('children' in node) {
            for (var i=0; i<node.children.length; i++) {
                var n =  node.children[i];
                //recursively call this function again
                calcRollupsReverse(n, node);
            }
        }
        
        var hasData = true;
        if(parent != null){        
            if ('dataRolledUp' in parent) {
                hasData = parent.dataRolledUp;
            } else {
                hasData = false;
            }
        }
        
        if (!hasData) {
            if( (!('data' in node)) || node.data == undefined ) {
                node.data = {};   
            }
            if(parent != null){
                if( (!('data' in parent)) || parent.data == undefined ) {
                    parent.data = {};
                }
                
                for (var x=0; x<dispXaxisObj.values.length; x++) {
                    var xId = dispXaxisObj.values[x].id;
                    var metVal = 0;
                    try { 
                        if (xId in node.data) {
                            //console.log('metval');
                            //console.log(metval);
                            metVal = node.data[xId];
                        } else {
                            //console.log('ERROR: (calcRollups) Metric not found in data. *' + xId + '*');
                            //console.log(dispXaxisObj.values[x]);
                            //console.log('n');
                        }
                    } catch(err) {
                        console.log('EXCEPTION node: ' + xId + '.  ' + err.message);
                        console.log(node);
                        return;
                    }    
                    
                    if (xId in parent.data) {
                        parent.data[xId] += metVal;
                    } else {
                        parent.data[xId] = metVal;
                    }   
                    
                }
            }
        }
    }
    
    


    //this function is going to separate out the amount that is booked to a node
    //from the amount that is rolled up to to a node from its children
    //at this point everything is rolled up.
    //we back into the number of what is booked to a node by subtracting the sum 
    //of the children from the rolled up amount
    function breakOutRollups(node) {
        breakOutRollupsWorker(node);
        return node;
    }
    function breakOutRollupsWorker(node) {
        if ('children' in node) {
            for (var i=0; i<node.children.length; i++) {
                var n = node.children[i];
                                
                //don't want to break out total nodes, this will double the breakout numbers
                if (n.type == 'Total') {
                    continue;
                }
                
                breakOutParentFromChild(node, n);
                //recursively call this function again
                breakOutRollupsWorker(n);
            }
        }
    }
    
    
    function breakOutParentFromChild(parent, child) {
        //iterate over all the dispXaxisObj values
        for (var x=0; x<dispXaxisObj.values.length; x++) {
            var xId = dispXaxisObj.values[x].id;
            
            //first move the rollup amounts to a new field if we haven't yet
            //EX: a1B1500000GIX1ZEAX_KNDY4__Balance_f__c => a1B1500000GIX1ZEAX_KNDY4__Balance_f__c__RU
            var xIdRU = xId + '__RU';
            if (!(xIdRU in parent.data)) {
                var RUval = 0;
                if ((xId in parent.data)) {
                    RUval = parent.data[xId];
                }
                parent.data[xIdRU] = RUval;
            }
            
            if (!(xIdRU in child.data)) {
                var RUval = 0;
                if ((xId in child.data)) {
                    RUval = child.data[xId];
                }
                child.data[xIdRU] = RUval;
            }            
            
            var metVal = 0;
            try { 
                if (xId in child.data) {
                    metVal = child.data[xId];
                } else {
                    //console.log('ERROR: (breakOutParentFromChild) Metric not found in data. *' + xId + '*');
                    //console.log(dispXaxisObj.values[x]);
                    //console.log('n');
                }
            } catch(err) {
                console.log('EXCEPTION node: ' + xId + '.  ' + err.message);
                console.log(child);
                return;
            }    
            
            if (xId in parent.data) {
                parent.data[xId] -= metVal;
            } else {
                parent.data[xId] = metVal;
            }     
        }                
    }
    

    function recurseChildrenDoCalcNetIncome(node, dispXaxisObj, asmRepTemp) {
        recurseChildrenDoCalcNetIncomeWorker(node, dispXaxisObj, asmRepTemp);
        return node;
    }
    function recurseChildrenDoCalcNetIncomeWorker(node, dispXaxisObj, asmRepTemp) {
        if ('children' in node) {
            for (var i=0; i<node.children.length; i++) {
                var n = node.children[i];
                
                if (n.type == 'Net Income') {
                    n.data = getNetIncome(n.filter);
                }
                
                //recursively call this function again
                recurseChildrenDoCalcNetIncomeWorker(n, dispXaxisObj, asmRepTemp);
            }
        }
    }
    
    function recurseChildrenDoCalcYaxis(node, dispXaxisObj, asmRepTemp) {
        recurseChildrenDoCalcYaxisWorker(node, dispXaxisObj, asmRepTemp);
        return node;
    }
    function recurseChildrenDoCalcYaxisWorker(node, dispXaxisObj, asmRepTemp) {
        if ('children' in node) {
            for (var i=0; i<node.children.length; i++) {
                var n = node.children[i];
                
                //first do the calculated sections (rows)
                if (n.type == 'Calculated') {
                    //get the formula
                    console.log('formula');
                    console.log(n.formula);
                    n.data = getCalcSlab(n.formula, dispXaxisObj, asmRepTemp);
                } 
                //recursively call this function again
                recurseChildrenDoCalcYaxisWorker(n, dispXaxisObj, asmRepTemp);
            }
        }
    }
    
    
    function recurseChildrenDoCumXaxis(node, dispXaxisObj) {
        recurseChildrenDoCumXaxisWorker(node, dispXaxisObj);
        return node;
    }
    function recurseChildrenDoCumXaxisWorker(node, dispXaxisObj) {
        if ('children' in node) {
            for (var i=0; i<node.children.length; i++) {
                var n = node.children[i];
                
                //do the cumulative columns
                doCumCols(n, dispXaxisObj);
                
                //recursively call this function again
                recurseChildrenDoCumXaxisWorker(n, dispXaxisObj);
            }
        }
    }        
    
    
    
    function recurseChildrenDoCalcXaxis(node, dispXaxisObj) {
        recurseChildrenDoCalcXaxisWorker(node, dispXaxisObj);
        return node;
    }
    function recurseChildrenDoCalcXaxisWorker(node, dispXaxisObj) {
        
        if ('children' in node) {
            for (var i=0; i<node.children.length; i++) {
                var n = node.children[i];
                
                //do the calculated columns
                doCalcCols(n, dispXaxisObj);
                
                //recursively call this function again
                recurseChildrenDoCalcXaxisWorker(n, dispXaxisObj);
            }
        }
    }    

    function recurseChildrenCheck0Balance(node, dispXaxisObj) {
        recurseChildrenCheck0BalanceWorker(node, dispXaxisObj);
        recurseChildrenRemove0BalanceNodes(node);
        return node;
    }
    
    function recurseChildrenRemove0BalanceNodes(node) {
        
        if ('children' in node) {
            //loop in reverse since we will be doing a splice to remove array elements
            for (var i = node.children.length-1; i>=0; i--) {
                var n = node.children[i];
                
                //we want to preserve certain nodes.  even if they have no balances in them we want to keep them.
                //for example Grouping sections should always show up, and Net Income sections should always show up.
                //so we will preserve anything which isn't a data node.
                var preserveNode = true;
                if ('type' in n) {
                    if (n.type == 'Data') {
                        preserveNode = false;
                    }
                    
                    //we don't want to preserve multi-dim total nodes
                    if (n.type == 'Total' || n.type == 'Calculated') {
                        //see if there are >1 dim
                        if (n.yDimVals.length > 1) {
                            preserveNode = false;
                        }
                    }                        
                    
                    
                }
                

                
                 //if there is no balance rolled up to this, and we aren't preserving the node, delete it.
                if ((!n.hasBalance) && (!preserveNode)) {
                    node.children.splice(i, 1);     
                }                

                //recursively call this function again
                recurseChildrenRemove0BalanceNodes(n);
            }
        }        
    }    
    
    
    function recurseChildrenCheck0BalanceWorker(node, dispXaxisObj) {
        check0Balance(node, dispXaxisObj);
        if ('children' in node) {
            for (var i=0; i<node.children.length; i++) {
                var n = node.children[i];
                
                check0Balance(n, dispXaxisObj);
                
                //recursively call this function again
                recurseChildrenCheck0BalanceWorker(n, dispXaxisObj);
            }
        } else {
            check0Balance(node, dispXaxisObj);            
        }
    }    
    
    function check0Balance(node, dispXaxisObj) {
        var hasBal = false;
        
        for (var x=0; x<dispXaxisObj.values.length; x++) {
                        
            //skip hidden columns.  we want to flag 0 balance for the node just for what is currently being shown.
            if (dispXaxisObj.values[x].hidden == true) {
                continue;
            }
            
            var xId = dispXaxisObj.values[x].id;
            var xIdRU = xId + '__RU';
            
            //just check the rollup amount.  because there may be nothing booked to this node
            //but if anything is rolled up to it we still want to include it
            
            if (node.data != undefined && xIdRU in node.data) {
                var metVal = node.data[xIdRU];
                if (metVal != null) {
                    if (metVal != 0) {
                        //no need to check all the visible columns, as soon as we find one with a balalnce we are done.
                        hasBal = true;
                        break;
                    }
                }
            } else {
                console.log('ERROR: (check0Balance) Metric not found in data. *' + xIdRU + '*');
                console.log('node');
            } 
        }
        
        node.hasBalance = hasBal;
    }
    
    
    
    function recurseChildrenDoPercentCalcXaxis(node, dispXaxisObj) {
        recurseChildrenDoPercentCalcXaxisWorker(node, dispXaxisObj);
        return node;
    }    
    function recurseChildrenDoPercentCalcXaxisWorker(node, dispXaxisObj) {
        if ('children' in node) {
            for (var i=0; i<node.children.length; i++) {
                var n = node.children[i];
                
                //do the calculated columns
                doCalcColsPercentages(n, dispXaxisObj);
                
                //recursively call this function again
                recurseChildrenDoPercentCalcXaxisWorker(n, dispXaxisObj);
            }
        }
    }        
    
    
    function getNetIncome(filter) {
        //init the net income data as 0
        var ni = {};
        for (var i=0; i<dispXaxisObj.values.length; i++) {
            var x = dispXaxisObj.values[i];
            ni[x.id] = 0;
        }
        
        var tempfilter = JSON.parse(JSON.stringify(filter));
        //loop over revenue GLs, add them to net income
        for (var i=0; i<revenueGLs.length; i++) {
            tempfilter.gltxnsum_glacct__c = revenueGLs[i];
            var row = getSlab(tempfilter);
            //console.log('getNetIncome revenueSlab');
            //console.log(JSON.parse(JSON.stringify(row)));
            //add these values to net income
            for (var j=0; j<dispXaxisObj.values.length; j++) {
                var x = dispXaxisObj.values[j];
                //console.log('getNetIncome revenueSlab GL: ' + revenueGLs[i] + ', period id: ' + x.id + ', ni[x.id] ' + ni[x.id] + ', row[x.id]: ' + row[x.id]);
                ni[x.id] += row[x.id];
            }
        }
        
        //loop over expense GLs, subtract them from net income
        for (var i=0; i<expenseGLs.length; i++) {
            tempfilter.gltxnsum_glacct__c = expenseGLs[i];
            var row = getSlab(tempfilter);
            //console.log('getNetIncome expenseSlab');
            //console.log(JSON.parse(JSON.stringify(row)));            
            //subtract these values from net income
            for (var j=0; j<dispXaxisObj.values.length; j++) {
                var x = dispXaxisObj.values[j];
                //console.log('getNetIncome expenseSlab GL: ' + expenseGLs[i] + ', id: ' + x.id + ', ni[x.id] ' + ni[x.id] + ', row[x.id]: ' + row[x.id]);

                ni[x.id] -= row[x.id];
            }
        }        
       
        //console.log('** NET INCOME'); 
        //console.log(JSON.parse(JSON.stringify(ni)));  
        ni[x.id+'__RU'] = ni[x.id];
        return ni;
    }
    
    
    function buildMetLevelMap(dispXaxisObj) {
        var metLevelMap = {};
        
        for (var x=0; x<dispXaxisObj.values.length; x++) {
            var xDim = dispXaxisObj.values[x];
            var metLevel = xDim.met + '|' + xDim.level;
            if (!(metLevel in metLevelMap)) {
                metLevelMap[metLevel] = [];
            }
            metLevelMap[metLevel].push(xDim.id+'__RU');
        }
        
        return metLevelMap;
    }
    
    function getDataId(xDim, sid, metLevelMap) {
        var dataId = xDim.id + '__RU';
        
        if ('offset' in sid) {
            var metLevel = xDim.met + '|' + xDim.level;
            var metLevels = metLevelMap[metLevel];
            var location = metLevels.indexOf(dataId);
            location = parseInt(location) + parseInt(sid.offset);
            if (location < 0) {
                dataId = null;
            } else {
                dataId = metLevels[location];
            }
        }
        
        return dataId;
    }

//this function takes in a formula that looks like this:
//(spaces added in comment below between the { and ! do VF doesn't interpret it as a VF merge field)
//{ !a0rj0000001jNnzAAE} - { !a0rj0000001jNo0AAE} - { !a0rj0000001jNo1AAE} - { !a0rj0000001jNo2AAE} - { !a0rj0000001jNo3AAE} - { !a0rj0000001jNo4AAE}
//and resolves all those Ids to node Ids in our report and gets the data attribute from each node and does the math on them
//the good new is that is the Id was entered in 15 digit format in the formula, the apex remote action converted it to 18 digit for us
//we will also support doing calculations on grouping section levels like this: { !Revenue} - { !Expense}
//or even the Id of an individual GL account

function getCalcSlab(formula, dispXaxisObj, asmRepTemp) {

    var calcData = {};

    //get all the data section Ids in the formula
    var sectionIds = formula.match(/\{\!.*?\}/g); 
    var sids  = [];
    var sections = [];
    
    if (sectionIds == null) {
        return;
    }
    
    //strip the merge tags off
    var sid;
    for(i=0; i<sectionIds.length; i++){
        sectionIds[i] = sectionIds[i].replace("{\!", "").replace("}", "");  
        sid = sectionIds[i].split('$');
        var objstorage = {};
        objstorage.sectionid = sid[0];
        if(sid.length > 1){
            objstorage.offset = sid[1];
        }
        sids.push(objstorage);
        sections.push(sid[0]);
    }                 
    
    var metLevelMap = buildMetLevelMap(dispXaxisObj);       
    console.log('metLevelMap');
    console.log(metLevelMap);
    
    
    //build a map of the section id to the data object in the section  
    var sectionData = getDataFromHier(sections, asmRepTemp);
    
    console.log('sectionData');
    console.log(sectionData);
    
    console.log('dispXaxisObj');
    console.log(dispXaxisObj);  
    
    //iterate over all the xAxis (period) dimensions and the metrics for each
    for (var x=0; x<dispXaxisObj.values.length; x++) {
        var xDim = dispXaxisObj.values[x];
        var formulaMerged = formula;
        
        for(y=0; y<sids.length; y++){
            var sectionId = sids[y].sectionid;
            //get the data object for this section
            var data = sectionData[sectionId];  
            
            try {
                //get the value at this level of the y hierachy and this xAxis value
                //var val = data[xDim.id];

                // Logic to calculate data section for calculated field but validating if data shouldnt be undefined
                // Edge case for calculating 'Movement of Cash' in Cash Flow Statement
                
                var val;
                var dataId;
                
                dataId = getDataId(xDim, sids[y], metLevelMap);
                
                if (dataId == null) {
                    val = 0;
                } else {
                    val = data[dataId];  
                }
                val = preProcessValForFormula(val);
                
                //replace the merge tag in the formula with the numeric value 
                formulaMerged = formulaMerged.replace(sectionIds[y], val);
                
                //replace merge tags with parens    
                formulaMerged = formulaMerged.replace(/{\!/g, "(").replace(/}/g, ")");                     
            } catch(err) {
                console.log('EXCEPTION: ' + xDim.id + ', f1 :' + formulaMerged + ', f2 :' + formulaMerged + '.  ' + err.message); 
                console.log(data); 
            }                
            
            
        }                   
        
        //console.log('*** formulaMerged: ' + formulaMerged);
        
        try {
            //pass to jison to parse the formula and calc the result
            calcData[xDim.id] = calculator.parse(formulaMerged);
            calcData[xDim.id+'__RU'] = calcData[xDim.id];
        } catch (e) {
            calcData[xDim.id] = null;
            calcData[xDim.id+'__RU'] = null;
            console.log('getCalcSlab Formula Parse Error: ' + e);
            console.log('formulaMerged: ' + formulaMerged);
        }       
        
    }       

    console.log('getCalcSlab sectionIds');
    console.log(sectionIds);
    
    return calcData;
}

    
    
function doCumCols(node, xAxisObj) {
    var nodeType = 'Data'; //default to Data if it doesn't exist
    if ('type' in node) {
        nodeType = node.type;
    }

    //KNDY-14819
    if(report.type == StatementType.IS && xAxisObj.dim == 'Period__c' && hideTotal == false){
        var cumcol = 0;
        for (var i=0; i<xAxisObj.values.length; i++) {
            var col = xAxisObj.values[i];

            if(col.hidden == false && col.id != 'total'){
                cumcol += node.data[col.id];
            }
        }
        node.data['total'] = cumcol;
    }
    
    
    /*if(report.type == StatementType.IS && xAxisObj.dim == 'Period__c'){
        for (var i=0; i<xAxisObj.values.length; i++) {
            var col = xAxisObj.values[i];
            if(col.level == 1){
                $.map(period13mapData, function(value,key){
                    var period13id      =   value + '_' + col.met;
                    var periodmapfyid   =   key + '_' + col.met;
                    if(col.id === periodmapfyid){
                        var newbal = node.data[col.id] - node.data[period13id];
                        node.data[col.id] = newbal;
                    }
                });
            }
        }
        
    }*/
    
    if (report.type == StatementType.MCTB) {
        //special case report.  End Bal = Beg Bal + DR - CR
        node.data.Transactional_Currency_a_KNDY4__Balance_f__c = 
            (node.data.begBalTrans + node.data.noDim_a_KNDY4__COMP_Transaction_Currency_Amount_DR__c - node.data.noDim_a_KNDY4__COMP_Transaction_Currency_Amount_CR__c);
        
        node.data.Functional_Currency_a_KNDY4__Balance_f__c = 
            (node.data.begBalFunc + node.data.noDim_a_KNDY4__COMP_Functional_Currency_Amount_DR__c - node.data.noDim_a_KNDY4__COMP_Functional_Currency_Amount_CR__c);
    }
    
    if (   ((report.type == StatementType.TB) || (report.type == StatementType.BS) || (report.type == StatementType.CF)) && (dispXaxisObj.dim == 'Period__c') ) {

        //initialize our cumulative values for every metric to 0
        var cumBals = {};
        for (var i=0; i<dispXaxisObj.values.length; i++) {
            var x = dispXaxisObj.values[i];
            cumBals[x.met] = 0;
        }
        
        //iterate over all the xAxis (period) dimensions and the metrics for each
        //we don't book anything to the quarter or year, period 13 skips quarter all together
        //so we are going to do cumulative at the period only, and then plunk those numbers into quarter and year        
        for (var i=0; i<dispXaxisObj.values.length; i++) {
            var x = overrideCol(node,dispXaxisObj.values[i]);
            var FYstart = false;
            if ('FYstart' in x && x.level == 3) {
                FYstart = x.FYstart;    
            }
            
            //reset cum balance if it is net income calculation and 
            //we are at the start of a fiscal year
            if ((nodeType == 'Net Income') && FYstart) {
                cumBals[x.met] = 0;
            }

            if (x.inOLAP || node.type == 'Calculated') {
                //cumulative cols only and handling cash flow edge case as well
                if (x.mode == 'cum') { 
                    var balVal = node.data[x.id];
                    
                    //only add the balance to the cumulative balance if we are at level 3 (period)
                    if (x.level == 3) {
                        cumBals[x.met] += balVal;
                    }
                    
                    node.data[x.id] = cumBals[x.met];
                   
                    if(node.type == 'Calculated'){
                        node.data[x.id+'__RU'] = cumBals[x.met];
                    }
                    
                }                     
            }       
            
        } 

    }
        
    //the begBal column defaults to the beg of time at 0.
    //however if you filter something after the beg of time, 
    //you need to re-set beg bal to the end bal of the last hidden period    
    if ( (report.type == StatementType.TB) && (dispXaxisObj.dim == 'Period__c') ) {
        
        //find the lowest level shown (highest number)
        //we will need this to know which ending bal level to pull forward to our beg bal
        
        //also build a map of levels and their columns inside each one
        //this map will only have the balance metric and not begBal
        var lowestLevelShown = 1;
        var levelToIdMap = {};
        for (var i=0; i<dispXaxisObj.values.length; i++) {
            var col = dispXaxisObj.values[i];
            
            if (!(col.level in levelToIdMap)) {
                levelToIdMap[col.level] = [];
            }
            if (col.met == 'Balance_f__c' && col.id != 'begBal') {
                levelToIdMap[col.level].push(col);
            }
           
            if ((!col.hidden) && (col.id != 'begBal')) {
                if (col.level > lowestLevelShown) {
                    lowestLevelShown = col.level;
                }
            }
        }                
        
        //console.log('lowestLevelShown: ' + lowestLevelShown);
        
        
        var hiddenPriorColsForLowestLevelShown = [];
        var bringBalForward = false;
        var colToBringFoward;
        
        //loop over the lowestLevelsShown columns.
        for (var i=0; i<levelToIdMap[lowestLevelShown].length; i++) {
            var col = levelToIdMap[lowestLevelShown][i];
            
            //store lowest level hidden bal columns
            if (col.hidden) {
                hiddenPriorColsForLowestLevelShown.push(col);
            }            
            
            //we can have various scenarios of shown and hidden columns before and after our filtered
            //range.
            //1) Shown  Shown  Shown
            //2) Shown  Shown  Hidden
            //3) Hidden Shown  Hidden
            //4) Hidden Shown  Shown
            //5) Hidden Hidden Hidden
            
            //we need to make sure to only set the begBal when there are hidden cols at the beginning and shown cols after
            //scenarios 3, 4 above
            
            if (!col.hidden && i==0) {
                //scenarios 1,2.  Our first column is shown.  break out, no need to bring anything forward.
                break;
            }
            
            //check for scenario 3,4 where there are hidden columns then shown columns.
            if (!col.hidden && hiddenPriorColsForLowestLevelShown.length > 0) {
                bringBalForward = true;
                //bring last hidden col forward
                colToBringFoward = hiddenPriorColsForLowestLevelShown[hiddenPriorColsForLowestLevelShown.length-1]; 
                break;     
            }
        }

        //console.log('bringBalForward: ' + bringBalForward);        
        
        //console.log('hiddenPriorColsForLowestLevelShown: ');
        //console.log(hiddenPriorColsForLowestLevelShown);

        //console.log('colToBringFoward: ');  
        //console.log(colToBringFoward);             
        
        if (bringBalForward) {
            node.data['begBal'] = node.data[colToBringFoward.id];
        }
        
        
    }
    
    return node;
    
}    
    
// function to overide schema properties to current node/col.    
function overrideCol(node, col){
    var localcol = $.extend(true, {}, col);
    
    for(key in node.metric){
        localcol[key] = node.metric[key];
    }
    return localcol;

}
    
function doCalcCols(node, xAxisObj) {
    //loop through and build a map of the data in this row for easy access
    var fieldToDataMap = buildFieldToDataMap(xAxisObj, node);

    //loop through and evaluate any formula columns
    for (var i=0; i<dispXaxisObj.values.length; i++) {
        //var col = dispXaxisObj.values[i];
        var col = overrideCol(node,dispXaxisObj.values[i]);
        
        if ((col.metType == 'Calculated') && (col.format != 'percent')) { //don't do percentages in this stage
                node.data[col.id] = calculateVal(col, fieldToDataMap, false);
                node.data[col.id+'__RU'] = calculateVal(col, fieldToDataMap, true);   
        }
        
        
    } 
    
}    
    
function doCalcColsPercentages(node, xAxisObj) {
    //loop through and build a map of the data in this row for easy access
    var fieldToDataMap = buildFieldToDataMap(xAxisObj, node);
    //console.log('doCalcColsPercentages fieldToDataMap');
    //console.log(fieldToDataMap);
    
    //loop through and evaluate any percentage formula columns
    for (var i=0; i<dispXaxisObj.values.length; i++) {
        var col = dispXaxisObj.values[i];
        if ((col.metType == 'Calculated') && (col.format == 'percent')) {
            //console.log('calculateVal percent');
            node.data[col.id] = calculateVal(col, fieldToDataMap, false);
            node.data[col.id+'__RU'] = calculateVal(col, fieldToDataMap, true);
        }
    } 
}        

    function buildFieldToDataMap(dispXaxisObj, node) {
        var fieldToDataMap = {};
        for (var i=0; i<dispXaxisObj.values.length; i++) {
            var col = dispXaxisObj.values[i];
            if(node.data != undefined){
                fieldToDataMap[col.id] = node.data[col.id];
                fieldToDataMap[col.id+'__RU'] = node.data[col.id+'__RU'];
            }
        }  
        return fieldToDataMap;
    }
    
    
    function calculateVal(col, fieldToDataMap, isRollup) {
        var formula = col.formula;
        var formulaMerged = formula;
        
        //parse out the regex metric (field) names from the formulas
        var arrMetNames = formula.match(/\{\!.*?\}/g);    
        if (arrMetNames == null) {
            return 0; //no fields, skip this one
        }
        
        //strip the merge tags off
        for(j=0; j<arrMetNames.length; j++){
            arrMetNames[j] = arrMetNames[j].replace("{\!", "").replace("}", "");  
        }                     
        
        //loop through the metrics and replace them with the data value from the corresponding metric
        //for the dimension we are in
        for(j=0; j<arrMetNames.length; j++){
            var metName = arrMetNames[j];
            
            try {
                //get the Id of the field for this dim and metName
                var metValId = dispXaxisObjDimToMetMap[col.dim][metName];
                
                if (isRollup) {
                    metValId += '__RU';
                }
                
                //get the data value from the data row object
                var metVal = fieldToDataMap[metValId];             
                
                metVal = preProcessValForFormula(metVal);
                
                //console.log('@@@@@@@@@@@@@@@@@@@@@   metValId: ' + metValId);
                //console.log('@@@@@@@@@@@@@@@@@@@@@   metVal: ' + metVal);
                
                //replace the field name with the proper data value for the dim/met combo
                formulaMerged = formulaMerged.replace(metName, metVal);
                
                //replace merge tags with parens    
                formulaMerged = formulaMerged.replace(/{\!/g, "(").replace(/}/g, ")");     
            } catch(err) {
                console.log('EXCEPTION: ' + metName + '.  ' + err.message);    
                console.log(col);     
            }                    
        }
        
        
        //console.log('*** formulaMerged: ' + formulaMerged);
        var calcVal = null;
        try {
            //pass to jison to parse the formula and calc the result
            calcVal = calculator.parse(formulaMerged);
        } catch (e) {
            calcVal = null;
            console.log('calculateVal Formula Parse Error: ' + e);
        }     
        //console.log('#################### calcVal: ' + calcVal);            
        
        if (calcVal == null) {
            calcVal = 0;
        } else if (!isFinite(calcVal)) {
            calcVal = 0;
        }
        
        return calcVal;
    }

    
    function preProcessValForFormula(val) {
        var ppVal = val;
        
        if (!isNaN(ppVal)) {
            //very small/big numbers come out as scientific notation, and we will get errors trying to use those.
            //we need to convert the number from sci notation to fixed precision like we do in the DB (KNDY-8530)                
            ppVal = ppVal.toFixed(6);        
        }
        
        return ppVal;
    }

    
function getDataFromHier(sectionIds, asmRepTemp) {
    //create an empty object to populate the data with
    var sectionData = {};
    for(i=0; i<sectionIds.length; i++){
        sectionData[sectionIds[i]] = null;
    }       
    
    console.log('getDataFromHier id asmRepTemp');
    console.log(asmRepTemp);
    recurseChildrenFindSections(asmRepTemp, sectionData, 'id');
    
    //if we didn't find some data by searching on id, let's search again on name
    var missingData = false;
    for(i=0; i<sectionIds.length; i++){
        if (sectionData[sectionIds[i]] == null) {
            missingData = true;
            break;
        }
    }       
    if (missingData) {
        console.log('getDataFromHier name asmRepTemp');
        console.log(asmRepTemp);        
        recurseChildrenFindSections(asmRepTemp, sectionData, 'name');
    }
    
    //see if we are missing anything
    for(i=0; i<sectionIds.length; i++){
        if (sectionData[sectionIds[i]] == null) {
            console.log("ERROR: Couldn't find data for id: " + sectionData[sectionIds[i]]);
        }
    }           

    return sectionData;
}
    
    
    
    function recurseChildrenFindSections(node, sectionData, matchOn) {
        if ('children' in node) {
            for (var i=0; i<node.children.length; i++) {
                var n = node.children[i];
                
                //try to match this node's id on any ids which we haven't found yet
                for (var s in sectionData) {
                    if (sectionData.hasOwnProperty(s)) {
                        if (sectionData[s] == null) {
                            
                            //console.log('*** s: ' + s + ', n[matchOn]: ' + n[matchOn]);
                            if (s == n[matchOn]) {
                                sectionData[s] = n.data;
                            }
                        }
                    }
                }        
                
                //see if we found everything or not
                var missingData = false;
                for (var s in sectionData) {
                    if (sectionData.hasOwnProperty(s)) {
                        if (sectionData[s] == null) {
                            missingData = true;
                            break;
                        }
                    }
                }               
                
                //recursively call this function again if there are still sections to populate
                if (missingData) {
                    recurseChildrenFindSections(n, sectionData, matchOn);
                }
            }
        }        
    }       
    



function recurseAndBuildFormat(node){
    if ('children' in node) {
        for (var i=0; i<node.children.length; i++) {
            var n = node.children[i];
            if(! ('format' in n)){
                node.children[i].format = node.format;
            }

            //recursively call this function again
            recurseAndBuildFormat(n);
        }
    }
}


    //lookhere
    
    
function recurseAndBuildFlatPresentationData(node) {
    recurseAndBuildFlatPresentationDataWorker(node, 0)
}    
    
function endsWith(str, suffix) {
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
}    
    
function recurseAndBuildFlatPresentationDataWorker(node, depth) {
    if ('children' in node) {
        //node.children.sort(hierSort); //call the custom sort on the flat data
        depth++;
        for (var i=0; i<node.children.length; i++) {
            var n = node.children[i];
            var supressNode = false;
            
            if (isFlatRollup) {
                supressNode = true;
                if ('isTopParent' in n) {
                    if (n.isTopParent) {
                        supressNode = false;
                    }    
                }
                if ('type' in n) {
                    if (n.type == 'Total') {
                        supressNode = true;
                    }
                }
            }
            
            var record = {};

            var nodeType = 'Other';
            var reportingAccount = false;
            if ('type' in n) {
                nodeType = n.type;
            }
            
            if('filter' in n){
                record.filter = JSON.stringify(n.filter);
            }
            
            if('reportingAccount' in n){
                reportingAccount = n.reportingAccount; 
            }
            
            
            if (reportMetadata.tree || isIndentedTree) {
                //tree data uses kendo treelist and we combine all the y axis dims into one field
                var yAxisCompField = model.yAxis.join('_');
                //add the yAxis field (for example GL Account_Sales)
                record[yAxisCompField] = n.name;                
            } else {
                for (var d=0; d<n.yDimVals.length; d++) {
                    var yDimVal = n.yDimVals[d];
                        record[yDimVal.objName] = yDimVal.name;    
                }
            }    

            record.nodeType = nodeType;
            record.order = n.order;
            record.depth = depth;
            record.reportingAccount = reportingAccount;            
            //add the Id and parent Id
            record.id = n.id;
            var parentId = null;
            if ('id' in node) {
                parentId = node.id;
            }
            record.parentId = parentId;
            
            //add in all the metric data
            if ('data' in n) {
                if (n.data != null) {
                    //loop over the dispXaxisObj to build the columns
                    for (var x=0; x<dispXaxisObj.values.length; x++) {
                        var xDim = dispXaxisObj.values[x];
                        
                        var dimId = xDim.id;
                        if (isFlatRollup) {
                            dimId += '__RU';
                        }
                        
                        record[xDim.id] = n.data[dimId];  

                        //add in the rolled up data too
                        var xIdRU = xDim.id + '__RU';
                        record[xIdRU] = n.data[xIdRU];  
                    }               
                }
            }

            var isEmptyNode = endsWith(n.id, '_empty');            
            var hasParent = (parentId != null);    
            var hasSiblings = (node.children.length > 1);
            var hasChildren = false;
            if ('children' in n) {
                if (n.children.length > 0) {
                    hasChildren = true;
                }
            }
            
            var supressEmptyNode = false;
            //if we are an "(Empty)" segment node, have a parent, and have no children or siblings
            if (isEmptyNode && hasParent && !hasSiblings && !hasChildren) {
                supressEmptyNode = true;
            }
            
            //if we are doing flat presentation data, and the number of dims in our y axis node is less than what is in the model
            //this means it is a total summary node. supress it from the flat data, since we will end up double counting those numbers
            //we just want the leaf nodes in here, not the subtotals
            var suppressSummaryNode = false;
            if ( (n.yDimVals.length < model.yAxis.length) && (!reportMetadata.tree) ) {
                suppressSummaryNode = true;
            }    
            
            //for isIndentedTree, and not rolled up we don't want to suppress anything.
            if (isIndentedTree) {
                if (isFlatRollup) {
                    if (depth == 1) {
                        supressNode = false;
                        suppressSummaryNode = false;
                    }
                } else {
                    supressNode = false;
                    suppressSummaryNode = false;                
                }  
                if (supressEmptyNode) {
                    supressNode = true;
                }
            }
            
            if (!supressNode) {
                if (!suppressSummaryNode) {
                    presentationData.push(record);
                }
            }    

            
            
            //recursively call this function again
            recurseAndBuildFlatPresentationDataWorker(n, depth);
        }
    }
}        
        
        
        

    //=========================================================
    // END API to query the completed OLAP cube
    //=========================================================





//====== BEGIN common methods used by multiple components
var updateStatus = function (msgLocation, statusMsg) { 
    setTimeout(function(){
        var statusObj = {'loc': msgLocation, 'msg': statusMsg};
        window.parent.postMessage({"type": "status", "status": statusObj}, "*");            
    }, 20);  
}; 


var checkErrors = function (event) { 
    var errorMsg;
    if (event.status) {            
        //do nothing, no error
    } else if (event.type === 'exception') {
        errorMsg = event.message + ' : ' + event.type;
    } else {
        errorMsg = event.message;
    }
    
    if (errorMsg != null) {
        var errorObj = {};
        errorObj.error = errorMsg;
        window.parent.postMessage({"type": "error", "error": errorObj}, "*");       
    }
    
};  
//====== END common methods used by multiple components
    
    
    
    
    //this function takes a salesforce object in JSON
    //and a relationship query style field reference like this: KNDY4__GL_Account__r.Name
    //and pulls the value we want out of the nested object(s)
    function resolveValue(obj, path, nullReplace) {
        
        //console.log('resolveValue path: ' + path + ', obj: ');
        //console.log(obj);

        var retVal = null;
        
        if (obj != null) {
            if (path in obj) {
                retVal = obj[path];
            } else {
                //loop through all the keys to fully resolve the final, nested value in the object tree
                var arrPath = path.split('.');
                var val = obj;
                for (var i=0; i<arrPath.length; i++) {
                    key = arrPath[i];
                    if (key in val) {
                        val = val[key];
                        retVal = val;
                    } else {
                        retVal = null;
                        break;
                    }
                }
            } 
        }

        if ((nullReplace != null) && (retVal == null)) {
            retVal = nullReplace;
        }
        return retVal;
    }
    
    
    
    function fileNameSafe(fileIn) {
        //replace anything not a letter or number with an underscore
        return fileIn.replace(/[^a-z0-9]/gi, '_');
    }    
    
    </script> 
</apex:page>